
# Generics in Java
- [Что такое дженерики?](#что-такое-дженерики)
- [Что было до дженерик?](#что-было-до-дженерик)


## **Что такое дженерики?**

Generic в Java представляют собой особые средства программирования которые позволяют не приводить типы данных явно и работать с различными типами данных одновременно.
Простым языком они могут использоваться в классах, интерфейсах и методах и позволяют принимать нам любой тип данных.

При создании классов, интерфейсов, методов с использованием Generic нам необходимо использовать спец. символ `<T>` или любую другую букву.

```
public class Box<T> {  
    private T value;  
     
    public void set(T value) {  
        this.value = value;  
    }  
     
    public T get() {  
        return value;  
    }  
}
```

В данном случае у нас имеется класс `Box<T>` который может хранить объект с любым типом данных. Этот тип будет определен при создании объекта.

##### **Дженерики решают проблему безопасности типов и повторяемости кода.**

Так же можно ограничивать типы Дженериков `<T extends Account>`
В данном случае мы ограничили использование только классом `Account` и его подтипами.

```
public class Main {  
    public static void main(String[] args) {  
        Account account1 = new Account(1234);  
        Account account2 = new Account(5678);  
        account1.setBalance(35);  
  
        Transaction<Account> tran1 = new Transaction<Account>(account1,account2,10);  
        tran1.execute();  
  
  
    }  
}  
  
class Transaction<T extends Account>{  
    private T from;  
    private T to;  
    private int amount;  
  
    public Transaction(T from, T to, int amount) {  
        this.from = from;  
        this.to = to;  
        this.amount = amount;  
    }  
  
    public void execute(){  
        if (from.getBalance() >= amount){  
            from.setBalance(from.getBalance() - amount);  
            System.out.println("Транзакция на счет " + to.getAccountNumber() + " совершена! Остаток на балансе " + from.getBalance());  
  
        }else{  
            System.out.println("Insufficient Balance");  
        }  
    }  
  
}  
  
class Account{  
    private int balance;  
    public int AccountNumber;  
  
    public Account(int accountNumber) {  
        this.AccountNumber = accountNumber;  
    }  
  
    public void setBalance(int balance) {  
        this.balance = balance;  
    }  
  
    public int getAccountNumber() {  
        return AccountNumber;  
    }  
  
    public int getBalance() {  
        return balance;  
    }  
}
```


## **Что было до дженерик?**

До дженерик в основном использовали `Object` - это означало, что в одну коллекцию можно было добавлять разные типы данных, но это вызывало проблемы с безопасностью и читаемостью кода. Это было не удобно.
 **В Java 5 были добавлены дженерики которые исправили эту ситуацию.**

### **Что можно типизировать?** 

| Классы       | Интерфейсы                | Методы | Коллекции | Конструкторы | Параметры и возвращаемые значения метода | Ограничения типов |     |
| ------------ | ------------------------- | ------ | --------- | ------------ | ---------------------------------------- | ----------------- | --- |
| **Wildcard** | **Массивы с дженериками** |        |           |              |                                          |                   |     |

Дженерики делают код безопасным для типов и удобным для работы с различными типами данных.

## **Что такое стирание и сырые типы (raw type - необработанный тип)?**

#### ==**Стирание типов(Type Erasure)**==

Стирание подразумевает собой, что компилятор удалит информацию о типах которые мы использовали в Дженерик после компиляции. 
Получается что на этапе выполнения вся информация о них стирается.

На этапе выполнения вся информация о типах дженериков удаляется, и код работает с обычными объектами `Object`. Таким образом, код дженериков преобразуется в код без дженериков.

```
// На этапе компиляции

public class Box<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

```
// Во время выполнения

public class Box { 
    private Object value;
  
    public void set(Object value) {
        this.value = value; 
    } 
  
    public Object get() {
        return value;
    }
}
```

Встает логичный вопрос. **Для чего это делается?**
- В первую очередь это сделано для совместимости с более старыми версии Java.
- Улучшение производительности JVM

#### **==Сырые типы(Raw Types)==**

Сырые типы это классы или интерфейсы без указания типа данных. 

```
// Пример без использования Generic

public class Main {  
    public static void main(String[] args) {  
        List list = new ArrayList();  // Сырой тип, не указан тип данных  
        list.add("Hello");  
        list.add(123);  // Можно добавить любой тип данных  
  
        String s = (String) list.get(0);  // Приведение типа вручную  
        System.out.println(s);  
    }  
}
```

```
// Пример с использованием Generic

public class Main {  
    public static void main(String[] args) {  
        List<String> list = new ArrayList<>();  // Использование дженериков  
        list.add("Hello");  
        // list.add(123);  // Ошибка компиляции: нельзя добавить Integer в список строк  
  
        String s = list.get(0);  // Приведение типа не нужно  
        System.out.println(s);  
    }  
}
```

В первом примере у нас возникают проблемы с безопасностью. Компилятор не может гарантировать правильность типа данных который мы будем использовать.

**Вопрос, когда нам использовать сырые типы?** 

В целом использовать сырые типы не рекомендуется, но мы можем использовать их в двух случаях.
1) При поддержке старого кода, в котором не поддерживаются дженерики.
2) При использовании рекурсии для вызова сырых типов


## **К чему приводит использование raw type?**

1. Приводит к потере безопасности типов, поскольку компилятор не проверяет корректность типов объектов.  
2.    Вызывает предупреждения компилятора, что указывает на потенциальные проблемы.  
3.    Может привести к ошибкам времени выполнения, таким как ClassCastException.  
4.    Нарушает совместимость с дженериками и может привести к неожиданным последствиям.  
5.    Ограничивает использование полезных функций дженериков, таких как подстановочные знаки и ограниченные типы.

**Поэтому использование сырых типов не рекомендуется. Вместо этого всегда лучше указывать параметризированные типы, чтобы гарантировать безопасность типов и избежать ошибок в программе.**


## **Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?**

Стирание типов обеспечивает обратную совместимость сырых типов и дженериков. 
Оно позволяет использовать дженерики в новых версиях.

Старый код использовал сырые типы и после выхода и добавления дженерик в Java 5 была внедрена система стирания типов, чтобы старый и новый код были совместимы.
JVM стирает наши дженерики во время выполнения и работает с сырыми типами как это было в старых версиях Java.

```
// До появления дженериков

List list = new ArrayList();  
list.add("Hello");  
String str = (String) list.get(0); // Явное приведение
```

```
// После добавления дженериков

List<String> list = new ArrayList<>();  
list.add("Hello");  
String str = list.get(0); // Без явного приведения
```

**Оба примера кода могут работать вместе благодаря стиранию типов. В новом коде дженерики добавляют типобезопасность на этапе компиляции, но на уровне байт-кода они работают так же, как и старый код.**

## **Если поле типизировано дженериком как в байт коде будет представлен этот тип?**

Когда поле типизировано дженериком, то никакой информации конкретно о дженерике и параметре типа не будет , так как у нас задействован механизм **стирания типов**.

Таким образом, **тип дженерика заменяется на** **Object**, а операции с типами на уровне байт-кода работают через приведение типов, обеспечивая типобезопасность на этапе выполнения.

Если дженерик имеет ограничение, например **T extends Number**, то в байт-коде тип **T** будет заменен на его **ограничение**

```
// В данном случае в байт-коде будет ограничение Number

public class Box<T extends Number> {
    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
```


## **Как параметризовать статический метод?**

Параметризировать статический метод при помощи Generic довольно просто. Это делается так же как и с обычными методами,но есть важный момент. 
Статические методы не имеют доступа к параметрам типа класса **(Если класс не параметризирован)** 
**Поэтому для статического метода мы объявляем собственный параметр типа.**

## **Что такое даймонд-оператор?

Даймонд-оператор `<>` это сокращение в синтаксисе для инициализации generic,которое введено в **Java 7**.

Он позволяет компилятору автоматически выводить типы при создании объектов.

```
// До появления даймонд-оператора

List<String> list = new ArrayList<String>();
```

```
// После появления даймонд-оператора

List<String> list = new ArrayList<>();
```

В случае использования анонимных классов или сложных выражений, типы нужно будет указать явно.

```
// Этот код вызывает ошибку,т.к. это анонимный класс и тип надо указать явно

List<String> list = new ArrayList<>() {
    {
        add("Hello");
        add("World");
    }
};
```

Нам надо указать тип явно, код должен выглядеть так:
```
List<String> list = new ArrayList<String>() {
    {
        // Здесь можно добавить элементы или выполнить любую другую инициализацию
        add("Hello");
        add("World");
    }
};
```

## **Чему эквивалентно `<?>`** 

`<?>` представляет собой универсальный тип **(wildcard)** который означает **любой тип**.
Мы говорим что принимаемый или возвращаемый тип может быть **любым объектом**, но при этом не хотим конкретизировать его.

Пример использования:

```
List<?> list = new ArrayList<String>();
```

`<?>` эквивалентен `<? extends Object>` - это означает что объект может быть любого типа,который является подтипом `Object`.

Пример чтения из списка Wildcard `<?>`:

```
public void printList(List<?> list) {
    for (Object element : list) {
        System.out.println(element);
    }
}
```

1. **Чтение возможно**, так как любой объект является подтипом `Object`.
2. **Запись невозможна**, за исключением добавления null, так как компилятор не знает конкретный тип данных, который будет допустим для вставки.

Пример когда запись не возможна: 

```
List<?> list = new ArrayList<String>();
list.add("test")
```

Сделаем вывод - `<?>` позволяет нам работать с дженериками или коллекциями не уточняя конкретного типа.
Однако это ограничивает возможность модификации содержимого коллекции.

## **Можно ли объявить так `class Animal<?>{}`?**

Нет. Так объявлять нельзя потому что `<?>` можно использовать только в параметризированных типах но не для их объявления.

Для параметризации класса необходимо использовать явные типы, такие как `T, E, K, V`.
`<?>` используется в методах или полях когда тип неизвестен.

## **Принцип PECS.**

Принцип **PECS** помогает правильно работать с дженериками в Java.

Аббревиатура расшифровывается **Procedure Extends Consumer Super**
Этот принцип объясняет когда следует использовать `<? extends T>` и  `<? super T>`

 `<? extends T>` используется когда параметризированный тип является поставщиком данных,тоесть только тогда когда мы **читаем данные**.

Пример:

```
public void processAnimals(List<? extends Animal> animals) {
    for (Animal animal : animals) {
        // Можно безопасно работать с объектами типа Animal или его подтипов
        animal.makeSound();
    }
}
```

`<? super T>` используется когда наш параметризированный тип является потребителем данных,тоесть мы передаем данные.

Пример: 

```
public void addAnimal(List<? super Animal> animals) {
    animals.add(new Dog());
    animals.add(new Cat());
}
```

## **WILDCARD**

Wildcard - это специальный символ `?` , который используется в случаях когда нам нужно обозначить неизвестный тип.
Он позволяет параметризировать тип когда конкретный тип не имеет значения.

**Виды Wildcard**:
- Неограниченный `<?>`
- Ограниченный `<? extentds T>`
- Ограниченный с супертипом `<? super T>`


## **Почему последняя строчка не скомпилируется?**

```
List<ArrayList> arrayLists = new ArrayList<ArrayList>();

ArrayList<List> arrayList = new ArrayList<ArrayList>(); // Не скомпилируется
```

Вторая строчка `ArrayList<List> arrayList = new ArrayList<ArrayList>();` не скомпилируется потому что возникает несовместимость типов.

В ней мы пытаемся присвоить объект типа `ArrayList<ArrayList>()` в переменную с типом `ArrayList<List>`,  это не корректно для компилятора.

**Хотя `ArrayList` является подтипом `List`, их использование в обобщённых типах (generics) не является ковариантным, то есть `ArrayList<ArrayList>` не является подтипом `ArrayList<List>`.**



