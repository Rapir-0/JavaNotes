## **Что такое дженерики?**

Generic в Java представляют собой особые средства программирования которые позволяют не приводить типы данных явно и работать с различными типами данных одновременно.
Простым языком они могут использоваться в классах, интерфейсах и методах и позволяют принимать нам любой тип данных.

При создании классов, интерфейсов, методов с использованием Generic нам необходимо использовать спец. символ `<T>` или любую другую букву.

```
public class Box<T> {  
    private T value;  
     
    public void set(T value) {  
        this.value = value;  
    }  
     
    public T get() {  
        return value;  
    }  
}
```

В данном случае у нас имеется класс `Box<T>` который может хранить объект с любым типом данных. Этот тип будет определен при создании объекта.

##### **Дженерики решают проблему безопасности типов и повторяемости кода.**

Так же можно ограничивать типы Дженериков `<T extends Account>`
В данном случае мы ограничили использование только классом `Account` и его подтипами.

```
public class Main {  
    public static void main(String[] args) {  
        Account account1 = new Account(1234);  
        Account account2 = new Account(5678);  
        account1.setBalance(35);  
  
        Transaction<Account> tran1 = new Transaction<Account>(account1,account2,10);  
        tran1.execute();  
  
  
    }  
}  
  
class Transaction<T extends Account>{  
    private T from;  
    private T to;  
    private int amount;  
  
    public Transaction(T from, T to, int amount) {  
        this.from = from;  
        this.to = to;  
        this.amount = amount;  
    }  
  
    public void execute(){  
        if (from.getBalance() >= amount){  
            from.setBalance(from.getBalance() - amount);  
            System.out.println("Транзакция на счет " + to.getAccountNumber() + " совершена! Остаток на балансе " + from.getBalance());  
  
        }else{  
            System.out.println("Insufficient Balance");  
        }  
    }  
  
}  
  
class Account{  
    private int balance;  
    public int AccountNumber;  
  
    public Account(int accountNumber) {  
        this.AccountNumber = accountNumber;  
    }  
  
    public void setBalance(int balance) {  
        this.balance = balance;  
    }  
  
    public int getAccountNumber() {  
        return AccountNumber;  
    }  
  
    public int getBalance() {  
        return balance;  
    }  
}
```


## **Что было до дженерик?**

До дженерик в основном использовали `Object` - это означало, что в одну коллекцию можно было добавлять разные типы данных, но это вызывало проблемы с безопасностью и читаемостью кода. Это было не удобно.
 **В Java 5 были добавлены дженерики которые исправили эту ситуацию.**

### **Что можно типизировать?** 

| Классы       | Интерфейсы                | Методы | Коллекции | Конструкторы | Параметры и возвращаемые значения метода | Ограничения типов |     |
| ------------ | ------------------------- | ------ | --------- | ------------ | ---------------------------------------- | ----------------- | --- |
| **Wildcard** | **Массивы с дженериками** |        |           |              |                                          |                   |     |

Дженерики делают код безопасным для типов и удобным для работы с различными типами данных.

## **Что такое стирание и сырые типы (raw type - необработанный тип)?**

#### ==**Стирание типов(Type Erasure)**==

Стирание подразумевает собой, что компилятор удалит информацию о типах которые мы использовали в Дженерик после компиляции. 
Получается что на этапе выполнения вся информация о них стирается.

На этапе выполнения вся информация о типах дженериков удаляется, и код работает с обычными объектами `Object`. Таким образом, код дженериков преобразуется в код без дженериков.

```
// На этапе компиляции

public class Box<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

```
// Во время выполнения

public class Box { 
    private Object value;
  
    public void set(Object value) {
        this.value = value; 
    } 
  
    public Object get() {
        return value;
    }
}
```

Встает логичный вопрос. **Для чего это делается?**
- В первую очередь это сделано для совместимости с более старыми версии Java.
- Улучшение производительности JVM

#### **==Сырые типы(Raw Types)==**

Сырые типы это классы или интерфейсы без указания типа данных. 

```
// Пример без использования Generic

public class Main {  
    public static void main(String[] args) {  
        List list = new ArrayList();  // Сырой тип, не указан тип данных  
        list.add("Hello");  
        list.add(123);  // Можно добавить любой тип данных  
  
        String s = (String) list.get(0);  // Приведение типа вручную  
        System.out.println(s);  
    }  
}
```

```
// Пример с использованием Generic

public class Main {  
    public static void main(String[] args) {  
        List<String> list = new ArrayList<>();  // Использование дженериков  
        list.add("Hello");  
        // list.add(123);  // Ошибка компиляции: нельзя добавить Integer в список строк  
  
        String s = list.get(0);  // Приведение типа не нужно  
        System.out.println(s);  
    }  
}
```

В первом примере у нас возникают проблемы с безопасностью. Компилятор не может гарантировать правильность типа данных который мы будем использовать.

**Вопрос, когда нам использовать сырые типы?** 

В целом использовать сырые типы не рекомендуется, но мы можем использовать их в двух случаях.
1) При поддержке старого кода, в котором не поддерживаются дженерики.
2) При использовании рекурсии для вызова сырых типов


## **К чему приводит использование raw type?**

1. Приводит к потере безопасности типов, поскольку компилятор не проверяет корректность типов объектов.  
2.    Вызывает предупреждения компилятора, что указывает на потенциальные проблемы.  
3.    Может привести к ошибкам времени выполнения, таким как ClassCastException.  
4.    Нарушает совместимость с дженериками и может привести к неожиданным последствиям.  
5.    Ограничивает использование полезных функций дженериков, таких как подстановочные знаки и ограниченные типы.

**Поэтому использование сырых типов не рекомендуется. Вместо этого всегда лучше указывать параметризированные типы, чтобы гарантировать безопасность типов и избежать ошибок в программе.**


## **Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?**

Стирание типов обеспечивает обратную совместимость сырых типов и дженериков. 
Оно позволяет использовать дженерики в новых версиях.

Старый код использовал сырые типы и после выхода и добавления дженерик в Java 5 была внедрена система стирания типов, чтобы старый и новый код были совместимы.
JVM стирает наши дженерики во время выполнения и работает с сырыми типами как это было в старых версиях Java.

```
// До появления дженериков

List list = new ArrayList();  
list.add("Hello");  
String str = (String) list.get(0); // Явное приведение
```

```
// После добавления дженериков

List<String> list = new ArrayList<>();  
list.add("Hello");  
String str = list.get(0); // Без явного приведения
```

**Оба примера кода могут работать вместе благодаря стиранию типов. В новом коде дженерики добавляют типобезопасность на этапе компиляции, но на уровне байт-кода они работают так же, как и старый код.**

test

