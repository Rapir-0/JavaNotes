
# Generics in Java

Содержание
- [Что такое дженерики?](#что-такое-дженерики)
- [Что было до дженерик?](#что-было-до-дженерик)
-  [Что можно типизировать?](#что-можно-типизировать)
- [Что такое стирание и сырые типы (raw type - необработанный тип)?](#что-такое-стирание-и-сырые-типы-raw-type---необработанный-тип)
- [К чему приводит использование raw type?](#к-чему-приводит-использование-raw-type)
-  [Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?](#какой-механизм-обеспечивает-обратную-совместимость-сырых-типов-и-дженериков)
-  [Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
-  [Как параметризовать статический метод?](#как-параметризовать-статический-метод)
-  [Что такое даймонд-оператор?](#что-такое-даймонд-оператор)
-  [Чему эквивалентно `<?>`](#чему-эквивалентно-)
-  [Можно ли объявить так `class Animal<?>{}`?](#можно-ли-объявить-так-class-animal)
- [Принцип PECS](#принцип-pecs)
-  [WILDCARD](#wildcard)
-  [Почему последняя строчка не скомпилируется?](#почему-последняя-строчка-не-скомпилируется)
- [Что такое коллекция?](#что-такое-коллекция)
- [Какие есть типы коллекций?](#какие-есть-типы-коллекций)
- [Отличие коллекции от массива.](#отличие-коллекции-от-массива)
- [Иерархия коллекций.](#иерархия-коллекций)
- [Внутреннее устройство коллекций.](#внутреннее-устройство-коллекций)







## **Что такое дженерики?**

Generic в Java представляют собой особые средства программирования которые позволяют не приводить типы данных явно и работать с различными типами данных одновременно.
Простым языком они могут использоваться в классах, интерфейсах и методах и позволяют принимать нам любой тип данных.

При создании классов, интерфейсов, методов с использованием Generic нам необходимо использовать спец. символ `<T>` или любую другую букву.

```
public class Box<T> {  
    private T value;  
     
    public void set(T value) {  
        this.value = value;  
    }  
     
    public T get() {  
        return value;  
    }  
}
```

В данном случае у нас имеется класс `Box<T>` который может хранить объект с любым типом данных. Этот тип будет определен при создании объекта.

##### **Дженерики решают проблему безопасности типов и повторяемости кода.**

Так же можно ограничивать типы Дженериков `<T extends Account>`
В данном случае мы ограничили использование только классом `Account` и его подтипами.

```
public class Main {  
    public static void main(String[] args) {  
        Account account1 = new Account(1234);  
        Account account2 = new Account(5678);  
        account1.setBalance(35);  
  
        Transaction<Account> tran1 = new Transaction<Account>(account1,account2,10);  
        tran1.execute();  
  
  
    }  
}  
  
class Transaction<T extends Account>{  
    private T from;  
    private T to;  
    private int amount;  
  
    public Transaction(T from, T to, int amount) {  
        this.from = from;  
        this.to = to;  
        this.amount = amount;  
    }  
  
    public void execute(){  
        if (from.getBalance() >= amount){  
            from.setBalance(from.getBalance() - amount);  
            System.out.println("Транзакция на счет " + to.getAccountNumber() + " совершена! Остаток на балансе " + from.getBalance());  
  
        }else{  
            System.out.println("Insufficient Balance");  
        }  
    }  
  
}  
  
class Account{  
    private int balance;  
    public int AccountNumber;  
  
    public Account(int accountNumber) {  
        this.AccountNumber = accountNumber;  
    }  
  
    public void setBalance(int balance) {  
        this.balance = balance;  
    }  
  
    public int getAccountNumber() {  
        return AccountNumber;  
    }  
  
    public int getBalance() {  
        return balance;  
    }  
}
```


## **Что было до дженерик?**

До дженерик в основном использовали `Object` - это означало, что в одну коллекцию можно было добавлять разные типы данных, но это вызывало проблемы с безопасностью и читаемостью кода. Это было не удобно.
 **В Java 5 были добавлены дженерики которые исправили эту ситуацию.**

### **Что можно типизировать?** 

| Классы       | Интерфейсы                | Методы | Коллекции | Конструкторы | Параметры и возвращаемые значения метода | Ограничения типов |     |
| ------------ | ------------------------- | ------ | --------- | ------------ | ---------------------------------------- | ----------------- | --- |
| **Wildcard** | **Массивы с дженериками** |        |           |              |                                          |                   |     |

Дженерики делают код безопасным для типов и удобным для работы с различными типами данных.

## **Что такое стирание и сырые типы (raw type - необработанный тип)?**

#### ==**Стирание типов(Type Erasure)**==

Стирание подразумевает собой, что компилятор удалит информацию о типах которые мы использовали в Дженерик после компиляции. 
Получается что на этапе выполнения вся информация о них стирается.

На этапе выполнения вся информация о типах дженериков удаляется, и код работает с обычными объектами `Object`. Таким образом, код дженериков преобразуется в код без дженериков.

```
// На этапе компиляции

public class Box<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

```
// Во время выполнения

public class Box { 
    private Object value;
  
    public void set(Object value) {
        this.value = value; 
    } 
  
    public Object get() {
        return value;
    }
}
```

Встает логичный вопрос. **Для чего это делается?**
- В первую очередь это сделано для совместимости с более старыми версии Java.
- Улучшение производительности JVM

#### **==Сырые типы(Raw Types)==**

Сырые типы это классы или интерфейсы без указания типа данных. 

```
// Пример без использования Generic

public class Main {  
    public static void main(String[] args) {  
        List list = new ArrayList();  // Сырой тип, не указан тип данных  
        list.add("Hello");  
        list.add(123);  // Можно добавить любой тип данных  
  
        String s = (String) list.get(0);  // Приведение типа вручную  
        System.out.println(s);  
    }  
}
```

```
// Пример с использованием Generic

public class Main {  
    public static void main(String[] args) {  
        List<String> list = new ArrayList<>();  // Использование дженериков  
        list.add("Hello");  
        // list.add(123);  // Ошибка компиляции: нельзя добавить Integer в список строк  
  
        String s = list.get(0);  // Приведение типа не нужно  
        System.out.println(s);  
    }  
}
```

В первом примере у нас возникают проблемы с безопасностью. Компилятор не может гарантировать правильность типа данных который мы будем использовать.

**Вопрос, когда нам использовать сырые типы?** 

В целом использовать сырые типы не рекомендуется, но мы можем использовать их в двух случаях.
1) При поддержке старого кода, в котором не поддерживаются дженерики.
2) При использовании рекурсии для вызова сырых типов


## **К чему приводит использование raw type?**

1. Приводит к потере безопасности типов, поскольку компилятор не проверяет корректность типов объектов.  
2.    Вызывает предупреждения компилятора, что указывает на потенциальные проблемы.  
3.    Может привести к ошибкам времени выполнения, таким как ClassCastException.  
4.    Нарушает совместимость с дженериками и может привести к неожиданным последствиям.  
5.    Ограничивает использование полезных функций дженериков, таких как подстановочные знаки и ограниченные типы.

**Поэтому использование сырых типов не рекомендуется. Вместо этого всегда лучше указывать параметризированные типы, чтобы гарантировать безопасность типов и избежать ошибок в программе.**


## **Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?**

Стирание типов обеспечивает обратную совместимость сырых типов и дженериков. 
Оно позволяет использовать дженерики в новых версиях.

Старый код использовал сырые типы и после выхода и добавления дженерик в Java 5 была внедрена система стирания типов, чтобы старый и новый код были совместимы.
JVM стирает наши дженерики во время выполнения и работает с сырыми типами как это было в старых версиях Java.

```
// До появления дженериков

List list = new ArrayList();  
list.add("Hello");  
String str = (String) list.get(0); // Явное приведение
```

```
// После добавления дженериков

List<String> list = new ArrayList<>();  
list.add("Hello");  
String str = list.get(0); // Без явного приведения
```

**Оба примера кода могут работать вместе благодаря стиранию типов. В новом коде дженерики добавляют типобезопасность на этапе компиляции, но на уровне байт-кода они работают так же, как и старый код.**

## **Если поле типизировано дженериком как в байт коде будет представлен этот тип?**

Когда поле типизировано дженериком, то никакой информации конкретно о дженерике и параметре типа не будет , так как у нас задействован механизм **стирания типов**.

Таким образом, **тип дженерика заменяется на** **Object**, а операции с типами на уровне байт-кода работают через приведение типов, обеспечивая типобезопасность на этапе выполнения.

Если дженерик имеет ограничение, например **T extends Number**, то в байт-коде тип **T** будет заменен на его **ограничение**

```
// В данном случае в байт-коде будет ограничение Number

public class Box<T extends Number> {
    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
```


## **Как параметризовать статический метод?**

Параметризировать статический метод при помощи Generic довольно просто. Это делается так же как и с обычными методами,но есть важный момент. 
Статические методы не имеют доступа к параметрам типа класса **(Если класс не параметризирован)** 
**Поэтому для статического метода мы объявляем собственный параметр типа.**

Пример: 

```
public class Utility {

    // Параметризованный статический метод
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] stringArray = {"Apple", "Banana", "Cherry"};

        // Вызов параметризованного метода
        printArray(intArray);    // Для массива Integer
        printArray(stringArray); // Для массива String
    }
}
```

## **Что такое даймонд-оператор?

Даймонд-оператор `<>` это сокращение в синтаксисе для инициализации generic,которое введено в **Java 7**.

Он позволяет компилятору автоматически выводить типы при создании объектов.

```
// До появления даймонд-оператора

List<String> list = new ArrayList<String>();
```

```
// После появления даймонд-оператора

List<String> list = new ArrayList<>();
```

В случае использования анонимных классов или сложных выражений, типы нужно будет указать явно.

```
// Этот код вызывает ошибку,т.к. это анонимный класс и тип надо указать явно

List<String> list = new ArrayList<>() {
    {
        add("Hello");
        add("World");
    }
};
```

Нам надо указать тип явно, код должен выглядеть так:
```
List<String> list = new ArrayList<String>() {
    {
        // Здесь можно добавить элементы или выполнить любую другую инициализацию
        add("Hello");
        add("World");
    }
};
```

## **Чему эквивалентно `<?>`** 

`<?>` представляет собой универсальный тип **(wildcard)** который означает **любой тип**.
Мы говорим что принимаемый или возвращаемый тип может быть **любым объектом**, но при этом не хотим конкретизировать его.

Пример использования:

```
List<?> list = new ArrayList<String>();
```

`<?>` эквивалентен `<? extends Object>` - это означает что объект может быть любого типа,который является подтипом `Object`.

Пример чтения из списка Wildcard `<?>`:

```
public void printList(List<?> list) {
    for (Object element : list) {
        System.out.println(element);
    }
}
```

1. **Чтение возможно**, так как любой объект является подтипом `Object`.
2. **Запись невозможна**, за исключением добавления null, так как компилятор не знает конкретный тип данных, который будет допустим для вставки.

Пример когда запись не возможна: 

```
List<?> list = new ArrayList<String>();
list.add("test")
```

Сделаем вывод - `<?>` позволяет нам работать с дженериками или коллекциями не уточняя конкретного типа.
Однако это ограничивает возможность модификации содержимого коллекции.

## **Можно ли объявить так `class Animal<?>{}`?**

Нет. Так объявлять нельзя потому что `<?>` можно использовать только в параметризированных типах но не для их объявления.

Для параметризации класса необходимо использовать явные типы, такие как `T, E, K, V`.
`<?>` используется в методах или полях когда тип неизвестен.

## **Принцип PECS**

Принцип **PECS** помогает правильно работать с дженериками в Java.

Аббревиатура расшифровывается **Procedure Extends Consumer Super**
Этот принцип объясняет когда следует использовать `<? extends T>` и  `<? super T>`

 `<? extends T>` используется когда параметризированный тип является поставщиком данных,тоесть только тогда когда мы **читаем данные**.

Пример:

```
public void processAnimals(List<? extends Animal> animals) {
    for (Animal animal : animals) {
        // Можно безопасно работать с объектами типа Animal или его подтипов
        animal.makeSound();
    }
}
```

`<? super T>` используется когда наш параметризированный тип является потребителем данных,тоесть мы передаем данные.

Пример: 

```
public void addAnimal(List<? super Animal> animals) {
    animals.add(new Dog());
    animals.add(new Cat());
}
```

## **WILDCARD**

Wildcard - это специальный символ `?` , который используется в случаях когда нам нужно обозначить неизвестный тип.
Он позволяет параметризировать тип когда конкретный тип не имеет значения.

**Виды Wildcard**:
- Неограниченный `<?>`
- Ограниченный `<? extentds T>`
- Ограниченный с супертипом `<? super T>`


## **Почему последняя строчка не скомпилируется?**

```
List<ArrayList> arrayLists = new ArrayList<ArrayList>();

ArrayList<List> arrayList = new ArrayList<ArrayList>(); // Не скомпилируется
```

Вторая строчка `ArrayList<List> arrayList = new ArrayList<ArrayList>();` не скомпилируется потому что возникает несовместимость типов.

В ней мы пытаемся присвоить объект типа `ArrayList<ArrayList>()` в переменную с типом `ArrayList<List>`,  это не корректно для компилятора.

**Хотя `ArrayList` является подтипом `List`, их использование в обобщённых типах (generics) не является ковариантным, то есть `ArrayList<ArrayList>` не является подтипом `ArrayList<List>`.**

# **Коллекции**

## **Что такое коллекция?**

В Java **коллекция** - это обхект,представляющий собой набор элементов, хранящихся в определенном порядке и по определенным правилам.

**Простыми словами, коллекция — это "коробка", в которую можно положить несколько элементов, таких как числа, строки или объекты, и потом легко их доставать, добавлять, удалять или искать.**

Пример: 

```
List<String> shoppingList = new ArrayList<>();
shoppingList.add("Хлеб");
shoppingList.add("Молоко");
```

## **Какие есть типы коллекций?**

В Java существует **5 основных** типов коллекций. Каждый тип коллекции предназначен для различных сценариев работы с данными.

### 1. **List (Список)**

| Описание               | Упорядоченный набор элементов, где каждый элемент имеет свой номер (индекс). Элементы могут повторяться.                    |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `ArrayList, LinkedList, Vector`                                                                                             |
| **Характеристики**     | **- Доступ по индексу.**<br>**- Поддерживает дубликаты.**<br>**- Можно вставлять и удалять элементы в любом месте списка.** |
Пример:
```
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Создаем список строк
        List<String> shoppingList = new ArrayList<>();
        
        // Добавляем элементы
        shoppingList.add("Хлеб");
        shoppingList.add("Молоко");
        shoppingList.add("Яйца");
        
        // Получаем элемент по индексу
        System.out.println(shoppingList.get(1)); // Выведет "Молоко"
    }
}
```
### 2. **Set (Множество)**

| Описание               | Коллекция, которая хранит только уникальные элементы (без повторений).                                                                                                     |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `HashSet, LinkedHashSet, TreeSet`                                                                                                                                          |
| **Характеристики**     | **- Не допускает повторяющихся элементов.**<br>**- Элементы не имеют индексов.**<br>**- Подходит для хранения уникальных значений, таких как ID или имена.**                |
Пример: 
```
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // Создаем множество
        Set<String> uniqueItems = new HashSet<>();
        
        // Добавляем элементы
        uniqueItems.add("Книга 1");
        uniqueItems.add("Книга 2");
        uniqueItems.add("Книга 1"); // Повтор, не будет добавлен
        
        // Вывод множества
        System.out.println(uniqueItems); // Выведет [Книга 1, Книга 2]
    }
}
```
### 3. **Queue (Очередь)**

| Описание               | Коллекция, которая работает по принципу "первым пришел — первым ушел" (FIFO — First In, First Out).                                                                         |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `LinkedList, PriorityQueue`                                                                                                                                                 |
| **Характеристики**     | **- Элементы добавляются в конец и извлекаются из начала.**<br>**- Используется в задачах, где важно соблюдать порядок обработки, как, например, в очередях на сервере.**   |
Пример:
```
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        // Создаем очередь
        Queue<String> queue = new LinkedList<>();
        
        // Добавляем элементы в очередь
        queue.add("Покупатель 1");
        queue.add("Покупатель 2");
        queue.add("Покупатель 3");
        
        // Извлекаем элемент из начала очереди
        System.out.println(queue.poll()); // Выведет "Покупатель 1"
    }
}
```
### 4. **Deque (Двусторонняя очередь)**

| Описание               | Коллекция, которая позволяет добавлять и удалять элементы с обеих сторон (как в начале, так и в конце).                                                                     |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `ArrayDeque, LinkedList`                                                                                                                                                    |
| **Характеристики**     | **- Двусторонний доступ к элементам (можно добавлять и удалять элементы с обоих концов).**<br>**- Подходит для задач, где важно иметь доступ к элементам с обеих сторон.**  |
Пример: 
```
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void main(String[] args) {
        // Создаем двустороннюю очередь
        Deque<String> deque = new ArrayDeque<>();
        
        // Добавляем элементы с обоих концов
        deque.addFirst("Первый");
        deque.addLast("Последний");
        
        // Извлекаем элементы
        System.out.println(deque.removeFirst()); // Выведет "Первый"
        System.out.println(deque.removeLast());  // Выведет "Последний"
    }
}
```
### 5. **Map (Отображение)**

| Описание               | Коллекция, которая хранит пары "ключ-значение". Каждый ключ уникален, а значение может быть связано с этим ключом.                                                          |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `HashMap, TreeMap, LinkedHashMap`                                                                                                                                           |
| **Характеристики**     | **- Хранит пары "ключ-значение".**<br>**- Ключи уникальны, но значения могут повторяться.**<br>**- Подходит для хранения данных, которые легко искать по ключу, как телефонная книга.** |
Пример:
```
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Создаем отображение (словарь)
        Map<String, String> phoneBook = new HashMap<>();
        
        // Добавляем записи в словарь
        phoneBook.put("Алиса", "123-4567");
        phoneBook.put("Боб", "987-6543");
        
        // Получаем значение по ключу
        System.out.println(phoneBook.get("Алиса")); // Выведет "123-4567"
    }
}
```


## **Отличие коллекции от массива.**

1. **Размер**
	Размер массива фиксиврован и устанавливается при его создании.
	
	**У коллекции же размер изменяется динамически.**
	
2. **Типы данных**
	Массивы могут хранить только элементы одного типа данных.
	
	**Коллекции же могут хранить объекты любого типа(При использовании Generics)**
	
3. **Функциональность** 
	Массивы предоставляют минимальные функции, такие как доступ к элементам по индексу, длина массива.
	
	**Коллекции предоставляют богатый набор методов для управления данными,таких как добавление удаление сортировка посик и др.**
	
4. **Производительность**
	Обычно операции с массивами очень быстры и эффективны.
	
	У коллекций же производительность может варьироаться в зависимости от их реализации,например `ArrayList` предоставляет быстрый доступ по индексу,но может быть медленным при добавлении или удалении.
	`LinkedList` наоборот,хорошо справляется с вставкой, но имеет медленный доступ по индексу.

## **Иерархия коллекций.**

В языке Java иерархия коллекций основана на интерфейсе `Collection`,который явзяется частью библиотеки `java.util`

Основные элементы:
1. **Collection** - базовый интерфейс для всех коллекций,содержит основные методы для работы с элементами.

2. **List** - упорядоченная коллекция,допускает дубликаты.

   - ArrayList - динамический массив
   - LinkedList - двусвязный список
   - Vector(устарел) - синхронизированный массив
   - Stack - наследник Vector реализует принцип LIFO(последним вошел,первым вышел)
   
3. **Set** - коллекция,которая не допускает дубликатов.

   - HashSet - неупорядоченный набор (использует таблицу)
   - LinkedHashSet - сохраняет порядок вставки элементов
   - TreeSet - отсортированный набор

4. **Queue** - для работы с очередями,поддерживает добавление в конец и удаление с начала.

   - PriorityQueue - очередь с приоритетом,где элементы извелкаются в порядке приоритета
   - LinkedList - также реализует интерфейс Queue

5. **Deque** - двусторонняя очередь,позволяет добавление и удаление элементов с обеих сторон.

   - ArrayDeque - реализация Deque на основе массива
   - LinkedList - также реализует Deque

7. **Map** - не является частью интерфеса `Collection` , но тесно с ним связан. Это коллекция пар **ключ - значение**.

   - HashMap - неупорядоченная карта, использует таблицу
   - LinkedHashMap - сохраняет порядок вставки
   - TreeMap - отсортированная карта
   - Hashtable(устарел) - сихронизированная карта

8. SortedSet и SortedMap - реализуются TreeSet TreeMap


## **Внутреннее устройство коллекций.**

Внутреннее устройство коллекций в Java зависит от их типа и функциональных особенностей. Вот краткий обзор ключевых аспектов:

### **1.** **ArrayList**

- В основе лежит **массив** динамической длины.
- По мере добавления элементов массив может **увеличиваться** (обычно в 1.5 раза).
- Быстрый доступ по индексу (O(1)), но **медленное удаление** или вставка в середину (O(n)).

### **2.** **LinkedList**

- Основан на **двусвязном списке**.
- Каждый элемент содержит ссылки на **предыдущий** и **следующий** элементы.
- Быстрое добавление и удаление в начале и конце (O(1)), но медленный доступ по индексу (O(n)).

### **3.** **Vector**

- Реализован на основе **массива** (как ArrayList), но все методы **синхронизированы**, что делает его медленнее.
- Увеличение массива при переполнении происходит в 2 раза.

### **4.** **Stack**

- Наследуется от Vector, работает по принципу **LIFO** (_последним вошел, первым вышел_).
- Использует методы push, pop, peek для управления элементами.

### **5.** **HashSet**

- Основан на **хэш-таблице** (_использует внутренний_ HashMap).
- Элементы **неупорядоченные**, и уникальность обеспечивается хэш-функцией.
- Операции вставки и поиска происходят за O(1), при условии хорошей хэш-функции.

### **6.** **LinkedHashSet**

- Наследуется от HashSet, но дополнительно сохраняет **порядок вставки** элементов.
- Внутри использует **связанный список** для поддержания порядка.

### **7.** **TreeSet**

- Основан на **красно-черном дереве** (_сбалансированном бинарном дереве поиска_).
- Элементы **отсортированы**, а операции добавления, удаления и поиска занимают O(log n).

### **8.** **PriorityQueue**

- Реализована на основе **двоичной кучи**.
- Элементы извлекаются согласно их приоритету, который определяется либо естественным порядком, либо компаратором.
- Вставка и извлечение занимают O(log n).

### **9.** **ArrayDeque**

- Основана на **массиве**, который расширяется по мере необходимости.
- Эффективно поддерживает операции вставки и удаления с обеих сторон (O(1)).

### **10.** **HashMap**

- В основе лежит **хэш-таблица**.
- Ключи и значения хранятся в **внутренних бакетах** (корзинах), выбранных по хэш-коду ключа.
- Операции вставки и получения значений происходят за O(1), при условии хорошего распределения хэш-кодов.
- При переполнении бакета (например, при коллизии) используется **связанный список** или **красно-черное дерево** (начиная с Java 8).

### **11.** **LinkedHashMap**

- Наследуется от HashMap, но поддерживает **порядок вставки**.
- Использует **связанный список** для хранения порядка элементов.

### **12.** **TreeMap**

- Основан на **красно-черном дереве**.
- Ключи отсортированы по естественному порядку или через компаратор.
- Операции вставки и поиска выполняются за O(log n).

### **13.** **Hashtable**

- Похож на HashMap, но все методы **синхронизированы**, что делает его менее эффективным.
- Как и HashMap, использует **хэш-таблицу** для хранения ключей и значений.

### **14.** **ConcurrentHashMap**

- Подобен HashMap, но разделен на сегменты для **одновременного доступа** несколькими потоками.
- Обеспечивает более высокую производительность при параллельной работе по сравнению с Hashtable.

### **15.** **WeakHashMap**

- Специфическая реализация Map, где ключи хранятся с помощью **слабых ссылок** (weak references).
- Ключи могут быть автоматически удалены сборщиком мусора, если на них нет жестких ссылок в других частях программы.

## **Какие структуры данных вы знаете.**

| **Структура данных** | **Описание**                                                                                 | **Плюсы**                                                                                                 | **Минусы**                                                                                   |
|----------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
| **Массив**            | Набор элементов одного типа, хранящихся в непрерывном блоке памяти                            | - Быстрый доступ по индексу <br> - Простая структура                                                       | - Фиксированный размер <br> - Трудоемкие операции добавления и удаления                      |
| **Связанный список**  | Элементы связаны через ссылки, каждый элемент указывает на следующий                          | - Легкость добавления/удаления <br> - Динамический размер                                                   | - Медленный доступ к элементам <br> - Большие затраты памяти на хранение указателей           |
| **Стек**             | Работает по принципу LIFO (последний пришел — первый ушел)                                     | - Простая реализация <br> - Удобен для возврата к предыдущему состоянию                                     | - Доступ только к верхнему элементу                                                          |
| **Очередь**          | Работает по принципу FIFO (первый пришел — первый ушел)                                        | - Полезна для обработки данных в порядке поступления                                                       | - Доступ только к началу и концу очереди                                                     |
| **Дерево**           | Состоит из узлов, один из которых — корень, остальные связаны через дочерние узлы              | - Эффективный поиск и модификация <br> - Подходит для иерархических данных                                 | - Сложная логика балансировки <br> - Плохая производительность, если дерево несбалансированное|
| **Хэш-таблица**      | Использует хэш-функцию для быстрого доступа к данным по ключу                                  | - Быстрый доступ по ключу <br> - Подходит для ассоциативного хранения                                       | - Возможны коллизии <br> - Зависит от качества хэш-функции                                   |
| **Граф**             | Состоит из вершин и ребер, соединяющих их                                                      | - Гибкость, подходит для моделирования сложных отношений (например, сети)                                   | - Сложность поиска <br> - Высокие затраты памяти                                             |
| **Куча**             | Бинарное дерево, где каждый родитель больше или меньше дочерних узлов                         | - Быстрая вставка и удаление <br> - Полезна для приоритетных очередей                                       | - Логарифмическое время операций <br> - Сложность реализации                                 |
| **Дек**              | Двусторонняя очередь, позволяет добавлять и удалять элементы с обеих концов                   | - Гибкость: поддерживает операции с обоих концов <br> - Можно использовать как стек или очередь             | - Более высокие затраты памяти и времени в некоторых реализациях                             |
