
# Generics in Java

Содержание

Дженерики
- [Что такое дженерики?](#что-такое-дженерики)
- [Что было до дженерик?](#что-было-до-дженерик)
-  [Что можно типизировать?](#что-можно-типизировать)
- [Что такое стирание и сырые типы (raw type - необработанный тип)?](#что-такое-стирание-и-сырые-типы-raw-type---необработанный-тип)
- [К чему приводит использование raw type?](#к-чему-приводит-использование-raw-type)
-  [Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?](#какой-механизм-обеспечивает-обратную-совместимость-сырых-типов-и-дженериков)
-  [Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
-  [Как параметризовать статический метод?](#как-параметризовать-статический-метод)
-  [Что такое даймонд-оператор?](#что-такое-даймонд-оператор)
-  [Чему эквивалентно `<?>`](#чему-эквивалентно-)
-  [Можно ли объявить так `class Animal<?>{}`?](#можно-ли-объявить-так-class-animal)
- [Принцип PECS](#принцип-pecs)
-  [WILDCARD](#wildcard)
-  [Почему последняя строчка не скомпилируется?](#почему-последняя-строчка-не-скомпилируется)

Коллекции
- [Что такое коллекция?](#что-такое-коллекция)
- [Какие есть типы коллекций?](#какие-есть-типы-коллекций)
- [Отличие коллекции от массива.](#отличие-коллекции-от-массива)
- [Иерархия коллекций.](#иерархия-коллекций)
- [Внутреннее устройство коллекций.](#внутреннее-устройство-коллекций)
- [Какие структуры данных вы знаете?](#какие-структуры-данных-вы-знаете)
- [Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)
- [Назовите основные реализации List, Set, Queue, Map](#назовите-основные-реализации-list-set-queue-map)
- [Может ли коллекция хранить примитивы? Как можно реализовать хранение примитивов?](#может-ли-коллекция-хранить-примитивы-как-можно-реализовать-хранение-примитивов)

List
- [Отличие List от Set.](#отличие-list-от-set)
- [Как устроен LinkedList?](#как-устроен-linkedlist)
- [Отличие ArrayList и LinkedList.](#отличие-arraylist-и-linkedlist)
- [Как работает метод contains в ArrayList и LinkedList?](#как-работает-метод-contains-в-arraylist-и-linkedlist)
- [Отличие двусвязного и односвязного списка](#отличие-двусвязного-и-односвязного-списка)

Set
- [Три реализации Set и их упорядоченность](#три-реализации-set-и-их-упорядоченность)
- [Как работает HashSet?](#как-работает-hashset)
- [Внутреннее устройство HashSet](#внутреннее-устройство-hashset)
- [Что кладется на место значения в HashSet?](#что-кладется-на-место-значения-в-hashset)
- [Почему в HashSet вместо value не null, а new Object](#почему-в-hashset-вместо-value-не-null-а-new-object)
- [Null в TreeSet](#null-в-treeset)
- [Как работает метод contains в HashSet](#как-работает-метод-contains-в-hashset)

Map
- [Что такое Map](#что-такое-map)
- [Почему Map не входит в Collection](#почему-map-не-входит-в-collection)
- [Строение HashMap и что внутри класса Node](#строение-hashmap-и-что-внутри-класса-node)
- [Как работает HashMap](#как-работает-hashmap)
- [Как расширяется HashMap](#как-расширяется-hashmap)
- [Может ли null быть ключом в HashMap](#может-ли-null-быть-ключом-в-hashmap)
- [Как работает метод put() в HashMap](#как-работает-метод-put-в-hashmap)
- [Как работает метод get() в HashMap](#как-работает-метод-get-в-hashmap)
- [Красно-черное дерево](#красно-черное-дерево)






## **Что такое дженерики?**

Generic в Java представляют собой особые средства программирования которые позволяют не приводить типы данных явно и работать с различными типами данных одновременно.
Простым языком они могут использоваться в классах, интерфейсах и методах и позволяют принимать нам любой тип данных.

При создании классов, интерфейсов, методов с использованием Generic нам необходимо использовать спец. символ `<T>` или любую другую букву.

```java
public class Box<T> {  
    private T value;  
     
    public void set(T value) {  
        this.value = value;  
    }  
     
    public T get() {  
        return value;  
    }  
}
```

В данном случае у нас имеется класс `Box<T>` который может хранить объект с любым типом данных. Этот тип будет определен при создании объекта.

##### **Дженерики решают проблему безопасности типов и повторяемости кода.**

Так же можно ограничивать типы Дженериков `<T extends Account>`
В данном случае мы ограничили использование только классом `Account` и его подтипами.

```java
public class Main {  
    public static void main(String[] args) {  
        Account account1 = new Account(1234);  
        Account account2 = new Account(5678);  
        account1.setBalance(35);  
  
        Transaction<Account> tran1 = new Transaction<Account>(account1,account2,10);  
        tran1.execute();  
  
  
    }  
}  
  
class Transaction<T extends Account>{  
    private T from;  
    private T to;  
    private int amount;  
  
    public Transaction(T from, T to, int amount) {  
        this.from = from;  
        this.to = to;  
        this.amount = amount;  
    }  
  
    public void execute(){  
        if (from.getBalance() >= amount){  
            from.setBalance(from.getBalance() - amount);  
            System.out.println("Транзакция на счет " + to.getAccountNumber() + " совершена! Остаток на балансе " + from.getBalance());  
  
        }else{  
            System.out.println("Insufficient Balance");  
        }  
    }  
  
}  
  
class Account{  
    private int balance;  
    public int AccountNumber;  
  
    public Account(int accountNumber) {  
        this.AccountNumber = accountNumber;  
    }  
  
    public void setBalance(int balance) {  
        this.balance = balance;  
    }  
  
    public int getAccountNumber() {  
        return AccountNumber;  
    }  
  
    public int getBalance() {  
        return balance;  
    }  
}
```


## **Что было до дженерик?**

До дженерик в основном использовали `Object` - это означало, что в одну коллекцию можно было добавлять разные типы данных, но это вызывало проблемы с безопасностью и читаемостью кода. Это было не удобно.
 **В Java 5 были добавлены дженерики которые исправили эту ситуацию.**

### **Что можно типизировать?** 

| Классы       | Интерфейсы                | Методы | Коллекции | Конструкторы | Параметры и возвращаемые значения метода | Ограничения типов |     |
| ------------ | ------------------------- | ------ | --------- | ------------ | ---------------------------------------- | ----------------- | --- |
| **Wildcard** | **Массивы с дженериками** |        |           |              |                                          |                   |     |

Дженерики делают код безопасным для типов и удобным для работы с различными типами данных.

## **Что такое стирание и сырые типы (raw type - необработанный тип)?**

#### ==**Стирание типов(Type Erasure)**==

Стирание подразумевает собой, что компилятор удалит информацию о типах которые мы использовали в Дженерик после компиляции. 
Получается что на этапе выполнения вся информация о них стирается.

На этапе выполнения вся информация о типах дженериков удаляется, и код работает с обычными объектами `Object`. Таким образом, код дженериков преобразуется в код без дженериков.

```java
// На этапе компиляции

public class Box<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

```java
// Во время выполнения

public class Box { 
    private Object value;
  
    public void set(Object value) {
        this.value = value; 
    } 
  
    public Object get() {
        return value;
    }
}
```

Встает логичный вопрос. **Для чего это делается?**
- В первую очередь это сделано для совместимости с более старыми версии Java.
- Улучшение производительности JVM

#### **==Сырые типы(Raw Types)==**

Сырые типы это классы или интерфейсы без указания типа данных. 

```java
// Пример без использования Generic

public class Main {  
    public static void main(String[] args) {  
        List list = new ArrayList();  // Сырой тип, не указан тип данных  
        list.add("Hello");  
        list.add(123);  // Можно добавить любой тип данных  
  
        String s = (String) list.get(0);  // Приведение типа вручную  
        System.out.println(s);  
    }  
}
```

```java
// Пример с использованием Generic

public class Main {  
    public static void main(String[] args) {  
        List<String> list = new ArrayList<>();  // Использование дженериков  
        list.add("Hello");  
        // list.add(123);  // Ошибка компиляции: нельзя добавить Integer в список строк  
  
        String s = list.get(0);  // Приведение типа не нужно  
        System.out.println(s);  
    }  
}
```

В первом примере у нас возникают проблемы с безопасностью. Компилятор не может гарантировать правильность типа данных который мы будем использовать.

**Вопрос, когда нам использовать сырые типы?** 

В целом использовать сырые типы не рекомендуется, но мы можем использовать их в двух случаях.
1) При поддержке старого кода, в котором не поддерживаются дженерики.
2) При использовании рекурсии для вызова сырых типов


## **К чему приводит использование raw type?**

1. Приводит к потере безопасности типов, поскольку компилятор не проверяет корректность типов объектов.  
2.    Вызывает предупреждения компилятора, что указывает на потенциальные проблемы.  
3.    Может привести к ошибкам времени выполнения, таким как ClassCastException.  
4.    Нарушает совместимость с дженериками и может привести к неожиданным последствиям.  
5.    Ограничивает использование полезных функций дженериков, таких как подстановочные знаки и ограниченные типы.

**Поэтому использование сырых типов не рекомендуется. Вместо этого всегда лучше указывать параметризированные типы, чтобы гарантировать безопасность типов и избежать ошибок в программе.**


## **Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?**

Стирание типов обеспечивает обратную совместимость сырых типов и дженериков. 
Оно позволяет использовать дженерики в новых версиях.

Старый код использовал сырые типы и после выхода и добавления дженерик в Java 5 была внедрена система стирания типов, чтобы старый и новый код были совместимы.
JVM стирает наши дженерики во время выполнения и работает с сырыми типами как это было в старых версиях Java.

```java
// До появления дженериков

List list = new ArrayList();  
list.add("Hello");  
String str = (String) list.get(0); // Явное приведение
```

```java
// После добавления дженериков

List<String> list = new ArrayList<>();  
list.add("Hello");  
String str = list.get(0); // Без явного приведения
```

**Оба примера кода могут работать вместе благодаря стиранию типов. В новом коде дженерики добавляют типобезопасность на этапе компиляции, но на уровне байт-кода они работают так же, как и старый код.**

## **Если поле типизировано дженериком как в байт коде будет представлен этот тип?**

Когда поле типизировано дженериком, то никакой информации конкретно о дженерике и параметре типа не будет , так как у нас задействован механизм **стирания типов**.

Таким образом, **тип дженерика заменяется на** **Object**, а операции с типами на уровне байт-кода работают через приведение типов, обеспечивая типобезопасность на этапе выполнения.

Если дженерик имеет ограничение, например **T extends Number**, то в байт-коде тип **T** будет заменен на его **ограничение**

```java
// В данном случае в байт-коде будет ограничение Number

public class Box<T extends Number> {
    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
```


## **Как параметризовать статический метод?**

Параметризировать статический метод при помощи Generic довольно просто. Это делается так же как и с обычными методами,но есть важный момент. 
Статические методы не имеют доступа к параметрам типа класса **(Если класс не параметризирован)** 
**Поэтому для статического метода мы объявляем собственный параметр типа.**

Пример: 

```java
public class Utility {

    // Параметризованный статический метод
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] stringArray = {"Apple", "Banana", "Cherry"};

        // Вызов параметризованного метода
        printArray(intArray);    // Для массива Integer
        printArray(stringArray); // Для массива String
    }
}
```

## **Что такое даймонд-оператор?

Даймонд-оператор `<>` это сокращение в синтаксисе для инициализации generic,которое введено в **Java 7**.

Он позволяет компилятору автоматически выводить типы при создании объектов.

```java
// До появления даймонд-оператора

List<String> list = new ArrayList<String>();
```

```java
// После появления даймонд-оператора

List<String> list = new ArrayList<>();
```

В случае использования анонимных классов или сложных выражений, типы нужно будет указать явно.

```java
// Этот код вызывает ошибку,т.к. это анонимный класс и тип надо указать явно

List<String> list = new ArrayList<>() {
    {
        add("Hello");
        add("World");
    }
};
```

Нам надо указать тип явно, код должен выглядеть так:
```java
List<String> list = new ArrayList<String>() {
    {
        // Здесь можно добавить элементы или выполнить любую другую инициализацию
        add("Hello");
        add("World");
    }
};
```

## **Чему эквивалентно `<?>`** 

`<?>` представляет собой универсальный тип **(wildcard)** который означает **любой тип**.
Мы говорим что принимаемый или возвращаемый тип может быть **любым объектом**, но при этом не хотим конкретизировать его.

Пример использования:

```java
List<?> list = new ArrayList<String>();
```

`<?>` эквивалентен `<? extends Object>` - это означает что объект может быть любого типа,который является подтипом `Object`.

Пример чтения из списка Wildcard `<?>`:

```java
public void printList(List<?> list) {
    for (Object element : list) {
        System.out.println(element);
    }
}
```

1. **Чтение возможно**, так как любой объект является подтипом `Object`.
2. **Запись невозможна**, за исключением добавления null, так как компилятор не знает конкретный тип данных, который будет допустим для вставки.

Пример когда запись не возможна: 

```java
List<?> list = new ArrayList<String>();
list.add("test")
```

Сделаем вывод - `<?>` позволяет нам работать с дженериками или коллекциями не уточняя конкретного типа.
Однако это ограничивает возможность модификации содержимого коллекции.

## **Можно ли объявить так `class Animal<?>{}`?**

Нет. Так объявлять нельзя потому что `<?>` можно использовать только в параметризированных типах но не для их объявления.

Для параметризации класса необходимо использовать явные типы, такие как `T, E, K, V`.
`<?>` используется в методах или полях когда тип неизвестен.

## **Принцип PECS**

Принцип **PECS** помогает правильно работать с дженериками в Java.

Аббревиатура расшифровывается **Procedure Extends Consumer Super**
Этот принцип объясняет когда следует использовать `<? extends T>` и  `<? super T>`

 `<? extends T>` используется когда параметризированный тип является поставщиком данных,тоесть только тогда когда мы **читаем данные**.

Пример:

```java
public void processAnimals(List<? extends Animal> animals) {
    for (Animal animal : animals) {
        // Можно безопасно работать с объектами типа Animal или его подтипов
        animal.makeSound();
    }
}
```

`<? super T>` используется когда наш параметризированный тип является потребителем данных,тоесть мы передаем данные.

Пример: 

```java
public void addAnimal(List<? super Animal> animals) {
    animals.add(new Dog());
    animals.add(new Cat());
}
```

## **WILDCARD**

Wildcard - это специальный символ `?` , который используется в случаях когда нам нужно обозначить неизвестный тип.
Он позволяет параметризировать тип когда конкретный тип не имеет значения.

**Виды Wildcard**:
- Неограниченный `<?>`
- Ограниченный `<? extentds T>`
- Ограниченный с супертипом `<? super T>`


## **Почему последняя строчка не скомпилируется?**

```java
List<ArrayList> arrayLists = new ArrayList<ArrayList>();

ArrayList<List> arrayList = new ArrayList<ArrayList>(); // Не скомпилируется
```

Вторая строчка `ArrayList<List> arrayList = new ArrayList<ArrayList>();` не скомпилируется потому что возникает несовместимость типов.

В ней мы пытаемся присвоить объект типа `ArrayList<ArrayList>()` в переменную с типом `ArrayList<List>`,  это не корректно для компилятора.

**Хотя `ArrayList` является подтипом `List`, их использование в обобщённых типах (generics) не является ковариантным, то есть `ArrayList<ArrayList>` не является подтипом `ArrayList<List>`.**

# **Коллекции**

## **Что такое коллекция?**

В Java **коллекция** - это обхект,представляющий собой набор элементов, хранящихся в определенном порядке и по определенным правилам.

**Простыми словами, коллекция — это "коробка", в которую можно положить несколько элементов, таких как числа, строки или объекты, и потом легко их доставать, добавлять, удалять или искать.**

Пример: 

```java
List<String> shoppingList = new ArrayList<>();
shoppingList.add("Хлеб");
shoppingList.add("Молоко");
```

## **Какие есть типы коллекций?**

В Java существует **5 основных** типов коллекций. Каждый тип коллекции предназначен для различных сценариев работы с данными.

### 1. **List (Список)**

| Описание               | Упорядоченный набор элементов, где каждый элемент имеет свой номер (индекс). Элементы могут повторяться.                    |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `ArrayList, LinkedList, Vector`                                                                                             |
| **Характеристики**     | **- Доступ по индексу.**<br>**- Поддерживает дубликаты.**<br>**- Можно вставлять и удалять элементы в любом месте списка.** |
Пример:
```java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Создаем список строк
        List<String> shoppingList = new ArrayList<>();
        
        // Добавляем элементы
        shoppingList.add("Хлеб");
        shoppingList.add("Молоко");
        shoppingList.add("Яйца");
        
        // Получаем элемент по индексу
        System.out.println(shoppingList.get(1)); // Выведет "Молоко"
    }
}
```
### 2. **Set (Множество)**

| Описание               | Коллекция, которая хранит только уникальные элементы (без повторений).                                                                                                     |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `HashSet, LinkedHashSet, TreeSet`                                                                                                                                          |
| **Характеристики**     | **- Не допускает повторяющихся элементов.**<br>**- Элементы не имеют индексов.**<br>**- Подходит для хранения уникальных значений, таких как ID или имена.**                |
Пример: 
```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // Создаем множество
        Set<String> uniqueItems = new HashSet<>();
        
        // Добавляем элементы
        uniqueItems.add("Книга 1");
        uniqueItems.add("Книга 2");
        uniqueItems.add("Книга 1"); // Повтор, не будет добавлен
        
        // Вывод множества
        System.out.println(uniqueItems); // Выведет [Книга 1, Книга 2]
    }
}
```
### 3. **Queue (Очередь)**

| Описание               | Коллекция, которая работает по принципу "первым пришел — первым ушел" (FIFO — First In, First Out).                                                                         |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `LinkedList, PriorityQueue`                                                                                                                                                 |
| **Характеристики**     | **- Элементы добавляются в конец и извлекаются из начала.**<br>**- Используется в задачах, где важно соблюдать порядок обработки, как, например, в очередях на сервере.**   |
Пример:
```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        // Создаем очередь
        Queue<String> queue = new LinkedList<>();
        
        // Добавляем элементы в очередь
        queue.add("Покупатель 1");
        queue.add("Покупатель 2");
        queue.add("Покупатель 3");
        
        // Извлекаем элемент из начала очереди
        System.out.println(queue.poll()); // Выведет "Покупатель 1"
    }
}
```
### 4. **Deque (Двусторонняя очередь)**

| Описание               | Коллекция, которая позволяет добавлять и удалять элементы с обеих сторон (как в начале, так и в конце).                                                                     |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `ArrayDeque, LinkedList`                                                                                                                                                    |
| **Характеристики**     | **- Двусторонний доступ к элементам (можно добавлять и удалять элементы с обоих концов).**<br>**- Подходит для задач, где важно иметь доступ к элементам с обеих сторон.**  |
Пример: 
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void main(String[] args) {
        // Создаем двустороннюю очередь
        Deque<String> deque = new ArrayDeque<>();
        
        // Добавляем элементы с обоих концов
        deque.addFirst("Первый");
        deque.addLast("Последний");
        
        // Извлекаем элементы
        System.out.println(deque.removeFirst()); // Выведет "Первый"
        System.out.println(deque.removeLast());  // Выведет "Последний"
    }
}
```
### 5. **Map (Отображение)**

| Описание               | Коллекция, которая хранит пары "ключ-значение". Каждый ключ уникален, а значение может быть связано с этим ключом.                                                          |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `HashMap, TreeMap, LinkedHashMap`                                                                                                                                           |
| **Характеристики**     | **- Хранит пары "ключ-значение".**<br>**- Ключи уникальны, но значения могут повторяться.**<br>**- Подходит для хранения данных, которые легко искать по ключу, как телефонная книга.** |
Пример:
```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Создаем отображение (словарь)
        Map<String, String> phoneBook = new HashMap<>();
        
        // Добавляем записи в словарь
        phoneBook.put("Алиса", "123-4567");
        phoneBook.put("Боб", "987-6543");
        
        // Получаем значение по ключу
        System.out.println(phoneBook.get("Алиса")); // Выведет "123-4567"
    }
}
```


## **Отличие коллекции от массива.**

1. **Размер**
	Размер массива фиксиврован и устанавливается при его создании.
	
	**У коллекции же размер изменяется динамически.**
	
2. **Типы данных**
	Массивы могут хранить только элементы одного типа данных.
	
	**Коллекции же могут хранить объекты любого типа(При использовании Generics)**
	
3. **Функциональность** 
	Массивы предоставляют минимальные функции, такие как доступ к элементам по индексу, длина массива.
	
	**Коллекции предоставляют богатый набор методов для управления данными,таких как добавление удаление сортировка посик и др.**
	
4. **Производительность**
	Обычно операции с массивами очень быстры и эффективны.
	
	У коллекций же производительность может варьироаться в зависимости от их реализации,например `ArrayList` предоставляет быстрый доступ по индексу,но может быть медленным при добавлении или удалении.
	`LinkedList` наоборот,хорошо справляется с вставкой, но имеет медленный доступ по индексу.

## **Иерархия коллекций.**

В языке Java иерархия коллекций основана на интерфейсе `Collection`,который явзяется частью библиотеки `java.util`.

Основные элементы:
1. **Collection** - базовый интерфейс для всех коллекций,содержит основные методы для работы с элементами.

2. **List** - упорядоченная коллекция,допускает дубликаты.

   - ArrayList - динамический массив
   - LinkedList - двусвязный список
   - Vector(устарел) - синхронизированный массив
   - Stack - наследник Vector реализует принцип LIFO(последним вошел,первым вышел)
   
3. **Set** - коллекция,которая не допускает дубликатов.

   - HashSet - неупорядоченный набор (использует таблицу)
   - LinkedHashSet - сохраняет порядок вставки элементов
   - TreeSet - отсортированный набор

4. **Queue** - для работы с очередями,поддерживает добавление в конец и удаление с начала.

   - PriorityQueue - очередь с приоритетом,где элементы извелкаются в порядке приоритета
   - LinkedList - также реализует интерфейс Queue

5. **Deque** - двусторонняя очередь,позволяет добавление и удаление элементов с обеих сторон.

   - ArrayDeque - реализация Deque на основе массива
   - LinkedList - также реализует Deque

7. **Map** - не является частью интерфеса `Collection` , но тесно с ним связан. Это коллекция пар **ключ - значение**.

   - HashMap - неупорядоченная карта, использует таблицу
   - LinkedHashMap - сохраняет порядок вставки
   - TreeMap - отсортированная карта
   - Hashtable(устарел) - сихронизированная карта

8. SortedSet и SortedMap - реализуются TreeSet TreeMap


## **Внутреннее устройство коллекций.**

Внутреннее устройство коллекций в Java зависит от их типа и функциональных особенностей. Вот краткий обзор ключевых аспектов:

### **1.** **ArrayList**

- В основе лежит **массив** динамической длины.
- По мере добавления элементов массив может **увеличиваться** (обычно в 1.5 раза).
- Быстрый доступ по индексу (O(1)), но **медленное удаление** или вставка в середину (O(n)).

### **2.** **LinkedList**

- Основан на **двусвязном списке**.
- Каждый элемент содержит ссылки на **предыдущий** и **следующий** элементы.
- Быстрое добавление и удаление в начале и конце (O(1)), но медленный доступ по индексу (O(n)).

### **3.** **Vector**

- Реализован на основе **массива** (как ArrayList), но все методы **синхронизированы**, что делает его медленнее.
- Увеличение массива при переполнении происходит в 2 раза.

### **4.** **Stack**

- Наследуется от Vector, работает по принципу **LIFO** (_последним вошел, первым вышел_).
- Использует методы push, pop, peek для управления элементами.

### **5.** **HashSet**

- Основан на **хэш-таблице** (_использует внутренний_ HashMap).
- Элементы **неупорядоченные**, и уникальность обеспечивается хэш-функцией.
- Операции вставки и поиска происходят за O(1), при условии хорошей хэш-функции.

### **6.** **LinkedHashSet**

- Наследуется от HashSet, но дополнительно сохраняет **порядок вставки** элементов.
- Внутри использует **связанный список** для поддержания порядка.

### **7.** **TreeSet**

- Основан на **красно-черном дереве** (_сбалансированном бинарном дереве поиска_).
- Элементы **отсортированы**, а операции добавления, удаления и поиска занимают O(log n).

### **8.** **PriorityQueue**

- Реализована на основе **двоичной кучи**.
- Элементы извлекаются согласно их приоритету, который определяется либо естественным порядком, либо компаратором.
- Вставка и извлечение занимают O(log n).

### **9.** **ArrayDeque**

- Основана на **массиве**, который расширяется по мере необходимости.
- Эффективно поддерживает операции вставки и удаления с обеих сторон (O(1)).

### **10.** **HashMap**

- В основе лежит **хэш-таблица**.
- Ключи и значения хранятся в **внутренних бакетах** (корзинах), выбранных по хэш-коду ключа.
- Операции вставки и получения значений происходят за O(1), при условии хорошего распределения хэш-кодов.
- При переполнении бакета (например, при коллизии) используется **связанный список** или **красно-черное дерево** (начиная с Java 8).

### **11.** **LinkedHashMap**

- Наследуется от HashMap, но поддерживает **порядок вставки**.
- Использует **связанный список** для хранения порядка элементов.

### **12.** **TreeMap**

- Основан на **красно-черном дереве**.
- Ключи отсортированы по естественному порядку или через компаратор.
- Операции вставки и поиска выполняются за O(log n).

### **13.** **Hashtable**

- Похож на HashMap, но все методы **синхронизированы**, что делает его менее эффективным.
- Как и HashMap, использует **хэш-таблицу** для хранения ключей и значений.

### **14.** **ConcurrentHashMap**

- Подобен HashMap, но разделен на сегменты для **одновременного доступа** несколькими потоками.
- Обеспечивает более высокую производительность при параллельной работе по сравнению с Hashtable.

### **15.** **WeakHashMap**

- Специфическая реализация Map, где ключи хранятся с помощью **слабых ссылок** (weak references).
- Ключи могут быть автоматически удалены сборщиком мусора, если на них нет жестких ссылок в других частях программы.

## **Какие структуры данных вы знаете?**

| **Структура данных** | **Описание**                                                                                 | **Плюсы**                                                                                                 | **Минусы**                                                                                   |
|----------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
| **Массив**            | Набор элементов одного типа, хранящихся в непрерывном блоке памяти                            | - Быстрый доступ по индексу <br> - Простая структура                                                       | - Фиксированный размер <br> - Трудоемкие операции добавления и удаления                      |
| **Связанный список**  | Элементы связаны через ссылки, каждый элемент указывает на следующий                          | - Легкость добавления/удаления <br> - Динамический размер                                                   | - Медленный доступ к элементам <br> - Большие затраты памяти на хранение указателей           |
| **Стек**             | Работает по принципу LIFO (последний пришел — первый ушел)                                     | - Простая реализация <br> - Удобен для возврата к предыдущему состоянию                                     | - Доступ только к верхнему элементу                                                          |
| **Очередь**          | Работает по принципу FIFO (первый пришел — первый ушел)                                        | - Полезна для обработки данных в порядке поступления                                                       | - Доступ только к началу и концу очереди                                                     |
| **Дерево**           | Состоит из узлов, один из которых — корень, остальные связаны через дочерние узлы              | - Эффективный поиск и модификация <br> - Подходит для иерархических данных                                 | - Сложная логика балансировки <br> - Плохая производительность, если дерево несбалансированное|
| **Хэш-таблица**      | Использует хэш-функцию для быстрого доступа к данным по ключу                                  | - Быстрый доступ по ключу <br> - Подходит для ассоциативного хранения                                       | - Возможны коллизии <br> - Зависит от качества хэш-функции                                   |
| **Граф**             | Состоит из вершин и ребер, соединяющих их                                                      | - Гибкость, подходит для моделирования сложных отношений (например, сети)                                   | - Сложность поиска <br> - Высокие затраты памяти                                             |
| **Куча**             | Бинарное дерево, где каждый родитель больше или меньше дочерних узлов                         | - Быстрая вставка и удаление <br> - Полезна для приоритетных очередей                                       | - Логарифмическое время операций <br> - Сложность реализации                                 |
| **Дек**              | Двусторонняя очередь, позволяет добавлять и удалять элементы с обеих концов                   | - Гибкость: поддерживает операции с обоих концов <br> - Можно использовать как стек или очередь             | - Более высокие затраты памяти и времени в некоторых реализациях                             |

## **Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?**

Порядок следования объектов в коллекции зависит от типа коллекции:

1. **List (список)**: Элементы хранятся в том порядке, в котором ты их добавляешь. Чтобы отсортировать список, можно использовать метод `sort()`. Например, в Java для сортировки списка используется `Collections.sort(твой_список)`.

2. **Set (множество)**: Обычные множества, такие как `HashSet`, не хранят элементы в определённом порядке. Если нужен порядок, можно использовать `TreeSet`, который автоматически сортирует элементы.

3. **Map (карта)**: В обычных `HashMap` порядок ключей не сохраняется. Но если нужен отсортированный порядок, можно использовать `TreeMap`, который хранит ключи в отсортированном виде.

Для сортировки элементов коллекции важно, чтобы объекты либо:
- Реализовывали интерфейс `Comparable`, который задает естественный порядок сортировки (например, числа по возрастанию, строки в алфавитном порядке).
- Либо можно передать специальный объект `Comparator`, который указывает, как сравнивать объекты между собой для сортировки.

### Простой пример сортировки списка в Java:
```java
List<String> список = new ArrayList<>();
список.add("яблоко");
список.add("банан");
список.add("вишня");

Collections.sort(список); // Отсортирует список по алфавиту
```


## **Назовите основные реализации List, Set, Queue, Map**

### **List (Список)**:
1. **ArrayList**: Самый популярный список. Хранит элементы в массиве. Подходит, если часто нужен быстрый доступ по индексу.
2. **LinkedList**: Хранит элементы в виде цепочки. Хорош для добавления и удаления элементов, но доступ по индексу медленнее.

### **Set (Множество)**:
1. **HashSet**: Хранит уникальные элементы в случайном порядке. Быстрое добавление, удаление и поиск.
2. **LinkedHashSet**: Как `HashSet`, но сохраняет порядок добавления элементов.
3. **TreeSet**: Хранит уникальные элементы в отсортированном порядке.

### **Queue (Очередь)**:
1. **LinkedList**: Реализует очередь, где элементы обрабатываются по порядку поступления (FIFO).
2. **PriorityQueue**: Очередь с приоритетами. Элементы обрабатываются не в порядке поступления, а по важности.

### **Map (Карта)**:
1. **HashMap**: Хранит пары "ключ-значение". Быстро находит значение по ключу, но не сохраняет порядок.
2. **LinkedHashMap**: Как `HashMap`, но сохраняет порядок добавления ключей.
3. **TreeMap**: Хранит ключи в отсортированном порядке.


## **Может ли коллекция хранить примитивы? Как можно реализовать хранение примитивов?**

Коллекция в Java не может напрямую хранить примитивные типы (например, `int`, `char`, `boolean`), потому что коллекции работают с объектами, а примитивы не являются объектами.

### Как хранить примитивы в коллекции?

Для хранения примитивных типов можно использовать **обертки** (wrapper classes), которые автоматически преобразуют примитивы в объекты. Java предоставляет такие классы для каждого примитивного типа:

- `int` → `Integer`
- `char` → `Character`
- `boolean` → `Boolean`
- `double` → `Double`

Этот процесс преобразования примитивов в объекты называется **автоупаковка** (autoboxing), а обратное преобразование — **распаковка** (unboxing).

Пример: 
```java
List<Integer> numbers = new ArrayList<>();
numbers.add(10); // Автоупаковка: 10 (int) превращается в Integer
numbers.add(20);
```

**Таким образом, коллекции могут хранить примитивы, но через их объектные аналоги — классы-обертки.**


# **List**

## **Отличие List от Set.**

| **Критерий**                | **List**                             | **Set**                              |
|-----------------------------|--------------------------------------|--------------------------------------|
| **Порядок элементов**        | Сохраняет порядок добавления         | Не гарантирует порядок (кроме `LinkedHashSet` и `TreeSet`) |
| **Допускает дубликаты**      | Да                                  | Нет, все элементы уникальны          |
| **Типы реализаций**          | `ArrayList`, `LinkedList`            | `HashSet`, `LinkedHashSet`, `TreeSet` |
| **Поиск элемента по индексу**| Возможен (метод `get(index)`)        | Нет индексов                         |
| **Производительность**       | Быстрее для доступа по индексу       | Быстрее для проверки наличия элемента |

## **Как устроен LinkedList?**

**LinkedList** — это структура данных, состоящая из элементов (узлов), где каждый элемент содержит:

1. **Данные** — сам элемент (например, число или строка).
2. **Ссылку на следующий элемент** — указатель на следующий узел в списке.

Узлы связаны друг с другом цепочкой. Первый узел называется **головой** (head), а последний — **хвостом** (tail). Это позволяет легко добавлять или удалять элементы в начале или конце списка.

### Преимущества:
- Быстрое добавление и удаление элементов, особенно в начале и конце.
  
### Недостатки:
- Медленный доступ к элементам по индексу, так как нужно пройти по узлам один за другим.

## **Отличие ArrayList и LinkedList.**

| **Критерий**                   | **ArrayList**                                       | **LinkedList**                                    |
|---------------------------------|----------------------------------------------------|--------------------------------------------------|
| **Структура хранения**          | Хранит элементы в массиве                          | Хранит элементы как узлы, связанные друг с другом |
| **Доступ по индексу**           | Быстрый доступ по индексу (O(1))                   | Медленный доступ, нужно пройти по всем элементам (O(n)) |
| **Добавление/удаление элемента**| Медленно, если добавлять/удалять в середине или начале (O(n)) | Быстрое добавление/удаление в начале или конце (O(1))  |
| **Затраты памяти**              | Меньше памяти, так как хранит только элементы      | Больше памяти, так как хранит указатели на соседние узлы |
| **Подходит для**                | Частого доступа по индексу, работы с небольшими изменениями | Частого добавления/удаления элементов в середине или начале списка |

## **Как работает метод contains в ArrayList и LinkedList?**

| **Критерий**                | **ArrayList**                                 | **LinkedList**                                |
|-----------------------------|-----------------------------------------------|-----------------------------------------------|
| **Как работает**             | Проходит по каждому элементу массива, чтобы найти совпадение (O(n)) | Проходит по каждому узлу, чтобы найти совпадение (O(n)) |
| **Скорость выполнения**      | Быстрее, так как элементы хранятся в массиве и доступны быстрее в памяти | Медленнее, так как нужно последовательно пройти по узлам |
| **Применение**               | Лучше использовать, когда требуется частый поиск | Подходит, когда поиск выполняется нечасто, а важны другие операции, например, добавление/удаление |

## **Отличие двусвязного и односвязного списка**

| **Критерий**             | **Односвязный список**                            | **Двусвязный список**                             |
|--------------------------|---------------------------------------------------|--------------------------------------------------|
| **Связи между элементами**| Каждый узел указывает только на следующий узел    | Каждый узел указывает на следующий и предыдущий узлы |
| **Добавление/удаление**   | Быстрое добавление/удаление только в начале       | Быстрое добавление/удаление как в начале, так и в конце |
| **Затраты памяти**        | Меньше памяти, так как хранит одну ссылку         | Больше памяти, так как хранит две ссылки (на предыдущий и следующий узел) |
| **Проход по элементам**   | Проход только в одном направлении (вперед)        | Проход возможен в обоих направлениях (вперед и назад) |
### **Когда использовать односвязный список:**

- Когда требуется **минимальные затраты памяти** (так как у каждого элемента хранится только одна ссылка).
- Если нужно часто **добавлять или удалять элементы только в начале списка**.
- Если **проход по элементам** всегда будет только в одном направлении (с начала до конца).

### **Когда использовать двусвязный список:**

- Когда необходимо **часто удалять или добавлять элементы как в начале, так и в конце списка**.
- Если нужен **двунаправленный доступ** к элементам (возможность двигаться как вперед, так и назад).
- В случаях, когда операции вставки и удаления могут происходить в середине списка, так как это легче реализовать с двусвязным списком.

Односвязные списки экономят память и проще в реализации, но двусвязные списки более гибкие и подходят для задач, где важно перемещение в обе стороны.


# **Set**

## **Три реализации Set и их упорядоченность**

1. **HashSet**
   - **Упорядоченность**: Нет порядка.
   - **Почему**: Хранит элементы в хэш-таблице, поэтому порядок добавления не сохраняется. Основная цель — быстрая проверка наличия элемента.

2. **LinkedHashSet**
   - **Упорядоченность**: Сохраняет порядок добавления.
   - **Почему**: Хранит элементы в связанном списке внутри, что позволяет сохранять порядок, в котором элементы были добавлены.

3. **TreeSet**
   - **Упорядоченность**: Элементы отсортированы.
   - **Почему**: Использует структуру бинарного дерева (красно-черное дерево), поэтому элементы автоматически сортируются по естественному порядку или по переданному компаратору.

## **Как работает HashSet?**

**HashSet** хранит элементы в хэш-таблице, что позволяет быстро проверять наличие элемента и выполнять операции добавления и удаления.

1. **Добавление элемента**: Когда элемент добавляется, его хэш-код вычисляется с помощью метода `hashCode()`. На основе этого хэш-кода элемент помещается в определённую "ячейку" в таблице.
2. **Проверка наличия элемента**: Для проверки элемента хэш-код снова вычисляется, и HashSet ищет элемент в соответствующей "ячейке".
3. **Коллизии**: Если два элемента имеют одинаковый хэш-код (коллизия), они хранятся в одной ячейке, но HashSet использует механизм сравнения элементов для их различия (метод `equals()`).
### Особенности:
- **Неупорядоченность**: Порядок элементов не сохраняется.
- **Быстрая проверка и добавление**: В среднем операции выполняются за O(1).

## **Внутреннее устройство HashSet**

**HashSet** использует для хранения элементов **хэш-таблицу**, которая обеспечивает быстрый доступ к элементам.

1. **Хэш-таблица**: Основная структура данных, на которой построен `HashSet`. Элементы распределяются по ячейкам (базам) на основе их хэш-кодов, которые вычисляются с помощью метода `hashCode()`.
2. **Хэш-код**: Каждый элемент получает свой уникальный хэш-код, который определяет, в какую ячейку будет помещён элемент.
3. **Коллизии**: Когда два элемента имеют одинаковый хэш-код, `HashSet` помещает их в одну и ту же ячейку, но сохраняет их как отдельные элементы с помощью связанного списка или другого метода разрешения коллизий.
4. **Метод `equals()`**: Используется для сравнения элементов внутри ячейки, если произошла коллизия.

### Особенности:
- **Быстрые операции**: Поиск, добавление и удаление элементов в среднем выполняются за O(1).
- **Неупорядоченность**: Элементы не хранятся в каком-либо определённом порядке, так как их расположение зависит от хэш-кода.

## **Что кладется на место значения в HashSet?**

В **HashSet** на место значения кладётся сам объект, который добавляется в множество. В отличие от **Map**, где есть пары "ключ-значение", в **HashSet** хранятся только элементы (ключи), и они выполняют роль значения.

## **Почему в HashSet вместо value не null, а new Object?**

Внутри **HashSet** используется **HashMap**, где элементы HashSet выступают в роли ключей, а вместо значений используется фиктивный объект `new Object()`. Это делается для того, чтобы:

1. Удовлетворить требование HashMap о паре "ключ-значение".
2. Избежать использования `null`, так как `null` может иметь особое значение в других контекстах и привести к ошибкам.
3. Использование `new Object()` гарантирует, что в качестве значения будет использоваться уникальный объект, который не несет смысловой нагрузки, а просто нужен для внутренней работы.

## **Null в TreeSet**

В **TreeSet** использование `null` недопустимо, так как эта структура данных основывается на бинарном дереве, где элементы должны быть сравнимыми для поддержания порядка. При попытке добавления `null` произойдет исключение `NullPointerException`.

1. **Почему**: TreeSet использует сравнение элементов через `Comparable` или `Comparator`, и `null` нельзя корректно сравнить с другими элементами.
2. **Исключение**: При добавлении `null` вызовется `NullPointerException`, так как `null` не поддерживает операции сравнения.

## **Как работает метод contains в HashSet**

Метод `contains()` в **HashSet** используется для проверки наличия элемента в множестве. Он работает на основе хэш-таблицы, и его работа можно описать так:

1. **Вычисление хэш-кода**: Когда вызывается метод `contains()`, хэш-код элемента вычисляется с помощью метода `hashCode()`. Этот хэш-код указывает, в какой ячейке хэш-таблицы нужно искать элемент.
2. **Поиск в ячейке**: Если в указанной ячейке есть несколько элементов (в случае коллизии), `HashSet` использует метод `equals()` для сравнения каждого элемента в ячейке с тем, который мы ищем.
3. **Возвращаемый результат**:
   - Если элемент найден, метод возвращает `true`.
   - Если элемент не найден, метод возвращает `false`.

### Особенности:
- **Скорость**: В среднем операция `contains()` выполняется за O(1), что делает её очень быстрой.
- **Коллизии**: Если несколько элементов попадают в одну ячейку (из-за одинаковых хэш-кодов), метод `contains()` использует `equals()` для их различия.


# **Map**

## **Что такое Map**

**Map** — это коллекция, которая хранит данные в виде пар "ключ-значение". Каждый ключ уникален и ассоциируется с одним значением. Это позволяет быстро находить значение по ключу.
### Основные особенности:
1. **Ключи уникальны**: В **Map** каждый ключ может встречаться только один раз. Если добавить новый элемент с тем же ключом, то старое значение будет заменено новым.
2. **Ассоциативное хранение**: Элементы хранятся как пары (ключ, значение), что позволяет легко находить значения по ключам.
3. **Типы Map**:
   - **HashMap**: Не сохраняет порядок элементов.
   - **LinkedHashMap**: Сохраняет порядок добавления элементов.
   - **TreeMap**: Хранит ключи в отсортированном порядке.

### Пример использования:
```java
Map<String, Integer> map = new HashMap<>();
map.put("яблоко", 5);  // Добавить ключ "яблоко" и значение 5
map.put("банан", 3);   // Добавить ключ "банан" и значение 3
int количество = map.get("яблоко");  // Получить значение для ключа "яблоко"
```

## **Почему Map не входит в Collection**

**Map** не входит в интерфейс **Collection**, потому что это совершенно другая структура данных с другой логикой работы:

1. **Map работает с парами "ключ-значение"**:
   - В отличие от коллекций, таких как **List**, **Set**, и **Queue**, где хранится просто набор элементов, **Map** хранит пары "ключ-значение". Это делает её принципиально иной структурой, так как она не оперирует отдельными элементами, а работает с парами.
2. **Отсутствие порядка**:
   - Коллекции, такие как **List** или **Set**, работают с упорядоченным или уникальным набором элементов. В то время как в **Map** каждый ключ уникален, но порядок ключей и значений может варьироваться (в зависимости от реализации — например, **HashMap** или **TreeMap**).
3. **Операции с ключами и значениями**:
   - Коллекции предоставляют методы для работы с элементами, такие как `add()`, `remove()`, и т.д. В **Map** же операции сосредоточены вокруг ключей и значений: `put()`, `get()`, и т.д., что кардинально отличается от логики работы коллекций.

### Пример:
```java
List<String> list = new ArrayList<>();  // Коллекция, которая хранит элементы
Map<String, Integer> map = new HashMap<>();  // Структура, которая хранит пары "ключ-значение"
```


## **Строение HashMap и что внутри класса Node**

###### **HashMap** — это структура данных, которая хранит элементы в виде пар "ключ-значение". Внутри она использует массив объектов класса **Node**, который представляет собой запись (entry) в хэш-таблице.

### Внутреннее строение HashMap:
1. **Массив Node[]**:
   - Основная структура **HashMap** — это массив объектов типа **Node**. Каждый элемент массива представляет собой "бакет" (bucket), где могут храниться одна или несколько записей.
2. **Хэш-функция**:
   - Ключи элементов преобразуются в хэш-коды с помощью метода `hashCode()`, а затем этот хэш используется для вычисления индекса массива, куда будет помещён элемент.
3. **Коллизии**:
   - Если несколько элементов имеют одинаковый хэш-код, они хранятся в одном бакете. Для этого используется либо связанный список, либо дерево (красно-черное дерево), если элементов слишком много в одном бакете (начиная с Java 8)
### Внутри класса **Node**:
```java
static class Node<K, V> {
    final int hash;        // Хэш-код ключа
    final K key;           // Ключ
    V value;               // Значение
    Node<K, V> next;       // Ссылка на следующий элемент (в случае коллизий)
}
```

1. **hash**: Хэш-код ключа, который помогает определить, куда помещать элемент в массиве.
2. **key**: Сам ключ элемента.
3. **value**: Значение, связанное с этим ключом.
4. **next**: Ссылка на следующий элемент в случае коллизии (если несколько ключей попадают в один и тот же бакет).

### Особенности:

- **Связанные списки**: Если возникает коллизия, несколько элементов могут быть связаны в цепочку через поле `next`.
- **Деревья**: В современных версиях Java (начиная с Java 8), если количество элементов в одном бакете превышает определённый порог, **HashMap** начинает использовать дерево вместо связанного списка для ускорения операций поиска.

## **Как работает HashMap**

**HashMap** хранит данные в виде пар "ключ-значение" и использует хэш-таблицу для быстрого доступа к элементам.

1. **Добавление элемента**:
   - При добавлении элемента ключ преобразуется в хэш-код с помощью метода `hashCode()`. Этот хэш-код используется для вычисления индекса массива, где будет храниться элемент.
2. **Коллизии**:
   - Если два ключа имеют одинаковый хэш-код (коллизия), **HashMap** использует либо связанный список, либо дерево (начиная с Java 8) для хранения нескольких элементов в одной ячейке.
3. **Поиск элемента**:
   - При вызове метода `get()` для поиска элемента по ключу, **HashMap** вычисляет хэш-код ключа, находит соответствующий бакет (ячейку массива) и затем проверяет элементы в этом бакете с помощью метода `equals()`.

### Пример:
```java
Map<String, Integer> map = new HashMap<>();
map.put("яблоко", 5);  // Добавить элемент
int count = map.get("яблоко");  // Найти элемент по ключу
```

## **Как расширяется HashMap**

**HashMap** автоматически расширяется (увеличивает размер внутреннего массива), когда количество элементов достигает определённого порога. Этот процесс называется **рехеширование**.

### Пример:
```java
Map<String, Integer> map = new HashMap<>(16, 0.75f);  // Инициализация с начальным размером и коэффициентом загрузки
for (int i = 0; i < 100; i++) {
    map.put("Ключ " + i, i);  // При достижении порога размер HashMap увеличится
}
```

## **Может ли null быть ключом в HashMap**

Да, в **HashMap** ключ может быть `null`. Однако есть несколько особенностей:

1. **Только один `null` ключ**: 
   - **HashMap** допускает только один ключ, равный `null`, потому что ключи в **HashMap** должны быть уникальными.
2. **Как работает `null` ключ**:
   - Если ключ равен `null`, **HashMap** не вычисляет его хэш-код (так как у `null` нет метода `hashCode()`). Вместо этого `null` ключ хранится в специальном "бакете", предназначенном для ключей без хэш-кодаи раверн 0.
3. **Особенности `put()` и `get()` для `null`**:
   - Метод `put(null, value)` добавляет значение для ключа `null`.
   - Метод `get(null)` возвращает значение, связанное с ключом `null`.

### Пример:
```java
Map<String, Integer> map = new HashMap<>();
map.put(null, 5);  // Добавляем значение для ключа null
System.out.println(map.get(null));  // Получаем значение для ключа null
```

## **Как работает метод put() в HashMap**

Метод **`put(K key, V value)`** добавляет пару "ключ-значение" в **HashMap**. Если ключ уже существует, его значение обновляется новым. Рассмотрим шаги работы метода:

1. **Проверка ключа на `null`**:
   - Если ключ **`key == null`**, **HashMap** кладёт этот ключ в специальный бакет для `null` ключей, так как у `null` нет хэш-кода. Для `null` всегда используется фиксированный хэш-код — **0**.
2. **Вычисление хэш-кода**:
   - Если ключ не равен `null`, **HashMap** вызывает метод **`hashCode()`** для ключа, чтобы получить хэш-код. Этот хэш-код затем используется для вычисления индекса в массиве бакетов, где будет храниться элемент.
   
   ```java
   int hash = hash(key);  // Вычисление хэш-кода ключа
   int index = (n - 1) & hash;  // Определение индекса бакета
```

3.  **Поиск бакета**:
    - По вычисленному индексу **HashMap** определяет, в какой бакет (ячейку массива) поместить ключ. Если бакет пустой, создаётся новая запись.
4. **Проверка на коллизии**:
    - Если в бакете уже есть элементы (коллизия), **HashMap** проверяет:
        - Если ключ совпадает (используя метод **`equals()`**), то значение обновляется новым.
        - Если это разные ключи, элемент добавляется в цепочку через связанный список, либо (начиная с Java 8) в виде дерева, если элементов слишком много в одном бакете.
5. **Рехеширование (при необходимости)**:
    - Если количество элементов превышает порог (определяемый коэффициентом загрузки), происходит **расширение** таблицы. Все элементы пересчитываются и распределяются заново в больший массив (см. рехеширование).
6. **Возврат старого значения**:
    - Если ключ уже существовал в **HashMap**, метод **`put()`** возвращает старое значение для этого ключа. Если ключ добавляется впервые, возвращается **`null`**
    

### Пример:
```java
Map<String, Integer> map = new HashMap<>();
map.put("яблоко", 5);  // Добавление нового элемента
map.put("яблоко", 10); // Обновление значения для ключа "яблоко"
```

## **Как работает метод get() в HashMap**

1. **Проверка на null**: Если ключ равен `null`, возвращается значение для ключа `null`.
2. **Вычисление хэш-кода**: Для ключа вызывается метод `hashCode()`, чтобы определить, в какой бакет поместить элемент.
3. **Поиск элемента**: В соответствующем бакете выполняется поиск элемента. Если есть несколько элементов (из-за коллизий), выполняется их сравнение через метод `equals()`.
4. **Возврат значения**: Если ключ найден, возвращается связанное с ним значение. Если ключ не найден, возвращается `null`.

---

## **Как работает метод remove() в HashMap**

1. **Проверка на null**: Если ключ равен `null`, удаляется элемент с ключом `null`.
2. **Вычисление хэш-кода**: Вычисляется хэш-код для ключа и находится соответствующий бакет.
3. **Поиск и удаление**: В бакете ищется элемент с соответствующим ключом, после чего он удаляется.
4. **Возврат значения**: Метод возвращает значение удалённого элемента или `null`, если элемент не был найден.

## **Красно-черное дерево**

**Красно-черное дерево** — это сбалансированное бинарное дерево поиска, которое поддерживает упорядоченность элементов и гарантирует, что его высота остаётся логарифмической относительно числа элементов.

### Основные свойства:
1. **Каждый узел имеет цвет**: Узел может быть либо красным, либо чёрным.
2. **Корень всегда чёрный**: Корневой узел всегда имеет чёрный цвет.
3. **Все листья — чёрные**: Листья (пустые узлы) всегда чёрные.
4. **Красные узлы не могут быть подряд**: Красный узел не может иметь красного родителя или ребёнка (должен быть разделён чёрным узлом).
5. **Одинаковый чёрный путь**: Для любого узла все пути от него до его потомков содержат одинаковое количество чёрных узлов.

### Преимущества:
- **Балансировка**: За счёт своих свойств дерево остаётся сбалансированным, что обеспечивает эффективные операции вставки, удаления и поиска.
- **Скорость**: Вставка, удаление и поиск выполняются за время O(log n).

### Использование:
Красно-черное дерево часто используется в реализациях таких структур данных, как **TreeMap** и **TreeSet**, чтобы поддерживать элементы в отсортированном порядке.

