
# Generics in Java

Содержание
- [Что такое дженерики?](#что-такое-дженерики)
- [Что было до дженерик?](#что-было-до-дженерик)
-  [Что можно типизировать?](#что-можно-типизировать)
- [Что такое стирание и сырые типы (raw type - необработанный тип)?](#что-такое-стирание-и-сырые-типы-raw-type---необработанный-тип)
- [К чему приводит использование raw type?](#к-чему-приводит-использование-raw-type)
-  [Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?](#какой-механизм-обеспечивает-обратную-совместимость-сырых-типов-и-дженериков)
-  [Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
-  [Как параметризовать статический метод?](#как-параметризовать-статический-метод)
-  [Что такое даймонд-оператор?](#что-такое-даймонд-оператор)
-  [Чему эквивалентно `<?>`](#чему-эквивалентно-)
-  [Можно ли объявить так `class Animal<?>{}`?](#можно-ли-объявить-так-class-animal)
- [Принцип PECS](#принцип-pecs)
-  [WILDCARD](#wildcard)
-  [Почему последняя строчка не скомпилируется?](#почему-последняя-строчка-не-скомпилируется)


## **Что такое дженерики?**

Generic в Java представляют собой особые средства программирования которые позволяют не приводить типы данных явно и работать с различными типами данных одновременно.
Простым языком они могут использоваться в классах, интерфейсах и методах и позволяют принимать нам любой тип данных.

При создании классов, интерфейсов, методов с использованием Generic нам необходимо использовать спец. символ `<T>` или любую другую букву.

```
public class Box<T> {  
    private T value;  
     
    public void set(T value) {  
        this.value = value;  
    }  
     
    public T get() {  
        return value;  
    }  
}
```

В данном случае у нас имеется класс `Box<T>` который может хранить объект с любым типом данных. Этот тип будет определен при создании объекта.

##### **Дженерики решают проблему безопасности типов и повторяемости кода.**

Так же можно ограничивать типы Дженериков `<T extends Account>`
В данном случае мы ограничили использование только классом `Account` и его подтипами.

```
public class Main {  
    public static void main(String[] args) {  
        Account account1 = new Account(1234);  
        Account account2 = new Account(5678);  
        account1.setBalance(35);  
  
        Transaction<Account> tran1 = new Transaction<Account>(account1,account2,10);  
        tran1.execute();  
  
  
    }  
}  
  
class Transaction<T extends Account>{  
    private T from;  
    private T to;  
    private int amount;  
  
    public Transaction(T from, T to, int amount) {  
        this.from = from;  
        this.to = to;  
        this.amount = amount;  
    }  
  
    public void execute(){  
        if (from.getBalance() >= amount){  
            from.setBalance(from.getBalance() - amount);  
            System.out.println("Транзакция на счет " + to.getAccountNumber() + " совершена! Остаток на балансе " + from.getBalance());  
  
        }else{  
            System.out.println("Insufficient Balance");  
        }  
    }  
  
}  
  
class Account{  
    private int balance;  
    public int AccountNumber;  
  
    public Account(int accountNumber) {  
        this.AccountNumber = accountNumber;  
    }  
  
    public void setBalance(int balance) {  
        this.balance = balance;  
    }  
  
    public int getAccountNumber() {  
        return AccountNumber;  
    }  
  
    public int getBalance() {  
        return balance;  
    }  
}
```


## **Что было до дженерик?**

До дженерик в основном использовали `Object` - это означало, что в одну коллекцию можно было добавлять разные типы данных, но это вызывало проблемы с безопасностью и читаемостью кода. Это было не удобно.
 **В Java 5 были добавлены дженерики которые исправили эту ситуацию.**

### **Что можно типизировать?** 

| Классы       | Интерфейсы                | Методы | Коллекции | Конструкторы | Параметры и возвращаемые значения метода | Ограничения типов |     |
| ------------ | ------------------------- | ------ | --------- | ------------ | ---------------------------------------- | ----------------- | --- |
| **Wildcard** | **Массивы с дженериками** |        |           |              |                                          |                   |     |

Дженерики делают код безопасным для типов и удобным для работы с различными типами данных.

## **Что такое стирание и сырые типы (raw type - необработанный тип)?**

#### ==**Стирание типов(Type Erasure)**==

Стирание подразумевает собой, что компилятор удалит информацию о типах которые мы использовали в Дженерик после компиляции. 
Получается что на этапе выполнения вся информация о них стирается.

На этапе выполнения вся информация о типах дженериков удаляется, и код работает с обычными объектами `Object`. Таким образом, код дженериков преобразуется в код без дженериков.

```
// На этапе компиляции

public class Box<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

```
// Во время выполнения

public class Box { 
    private Object value;
  
    public void set(Object value) {
        this.value = value; 
    } 
  
    public Object get() {
        return value;
    }
}
```

Встает логичный вопрос. **Для чего это делается?**
- В первую очередь это сделано для совместимости с более старыми версии Java.
- Улучшение производительности JVM

#### **==Сырые типы(Raw Types)==**

Сырые типы это классы или интерфейсы без указания типа данных. 

```
// Пример без использования Generic

public class Main {  
    public static void main(String[] args) {  
        List list = new ArrayList();  // Сырой тип, не указан тип данных  
        list.add("Hello");  
        list.add(123);  // Можно добавить любой тип данных  
  
        String s = (String) list.get(0);  // Приведение типа вручную  
        System.out.println(s);  
    }  
}
```

```
// Пример с использованием Generic

public class Main {  
    public static void main(String[] args) {  
        List<String> list = new ArrayList<>();  // Использование дженериков  
        list.add("Hello");  
        // list.add(123);  // Ошибка компиляции: нельзя добавить Integer в список строк  
  
        String s = list.get(0);  // Приведение типа не нужно  
        System.out.println(s);  
    }  
}
```

В первом примере у нас возникают проблемы с безопасностью. Компилятор не может гарантировать правильность типа данных который мы будем использовать.

**Вопрос, когда нам использовать сырые типы?** 

В целом использовать сырые типы не рекомендуется, но мы можем использовать их в двух случаях.
1) При поддержке старого кода, в котором не поддерживаются дженерики.
2) При использовании рекурсии для вызова сырых типов


## **К чему приводит использование raw type?**

1. Приводит к потере безопасности типов, поскольку компилятор не проверяет корректность типов объектов.  
2.    Вызывает предупреждения компилятора, что указывает на потенциальные проблемы.  
3.    Может привести к ошибкам времени выполнения, таким как ClassCastException.  
4.    Нарушает совместимость с дженериками и может привести к неожиданным последствиям.  
5.    Ограничивает использование полезных функций дженериков, таких как подстановочные знаки и ограниченные типы.

**Поэтому использование сырых типов не рекомендуется. Вместо этого всегда лучше указывать параметризированные типы, чтобы гарантировать безопасность типов и избежать ошибок в программе.**


## **Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?**

Стирание типов обеспечивает обратную совместимость сырых типов и дженериков. 
Оно позволяет использовать дженерики в новых версиях.

Старый код использовал сырые типы и после выхода и добавления дженерик в Java 5 была внедрена система стирания типов, чтобы старый и новый код были совместимы.
JVM стирает наши дженерики во время выполнения и работает с сырыми типами как это было в старых версиях Java.

```
// До появления дженериков

List list = new ArrayList();  
list.add("Hello");  
String str = (String) list.get(0); // Явное приведение
```

```
// После добавления дженериков

List<String> list = new ArrayList<>();  
list.add("Hello");  
String str = list.get(0); // Без явного приведения
```

**Оба примера кода могут работать вместе благодаря стиранию типов. В новом коде дженерики добавляют типобезопасность на этапе компиляции, но на уровне байт-кода они работают так же, как и старый код.**

## **Если поле типизировано дженериком как в байт коде будет представлен этот тип?**

Когда поле типизировано дженериком, то никакой информации конкретно о дженерике и параметре типа не будет , так как у нас задействован механизм **стирания типов**.

Таким образом, **тип дженерика заменяется на** **Object**, а операции с типами на уровне байт-кода работают через приведение типов, обеспечивая типобезопасность на этапе выполнения.

Если дженерик имеет ограничение, например **T extends Number**, то в байт-коде тип **T** будет заменен на его **ограничение**

```
// В данном случае в байт-коде будет ограничение Number

public class Box<T extends Number> {
    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
```


## **Как параметризовать статический метод?**

Параметризировать статический метод при помощи Generic довольно просто. Это делается так же как и с обычными методами,но есть важный момент. 
Статические методы не имеют доступа к параметрам типа класса **(Если класс не параметризирован)** 
**Поэтому для статического метода мы объявляем собственный параметр типа.**

Пример: 

```
public class Utility {

    // Параметризованный статический метод
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] stringArray = {"Apple", "Banana", "Cherry"};

        // Вызов параметризованного метода
        printArray(intArray);    // Для массива Integer
        printArray(stringArray); // Для массива String
    }
}
```

## **Что такое даймонд-оператор?

Даймонд-оператор `<>` это сокращение в синтаксисе для инициализации generic,которое введено в **Java 7**.

Он позволяет компилятору автоматически выводить типы при создании объектов.

```
// До появления даймонд-оператора

List<String> list = new ArrayList<String>();
```

```
// После появления даймонд-оператора

List<String> list = new ArrayList<>();
```

В случае использования анонимных классов или сложных выражений, типы нужно будет указать явно.

```
// Этот код вызывает ошибку,т.к. это анонимный класс и тип надо указать явно

List<String> list = new ArrayList<>() {
    {
        add("Hello");
        add("World");
    }
};
```

Нам надо указать тип явно, код должен выглядеть так:
```
List<String> list = new ArrayList<String>() {
    {
        // Здесь можно добавить элементы или выполнить любую другую инициализацию
        add("Hello");
        add("World");
    }
};
```

## **Чему эквивалентно `<?>`** 

`<?>` представляет собой универсальный тип **(wildcard)** который означает **любой тип**.
Мы говорим что принимаемый или возвращаемый тип может быть **любым объектом**, но при этом не хотим конкретизировать его.

Пример использования:

```
List<?> list = new ArrayList<String>();
```

`<?>` эквивалентен `<? extends Object>` - это означает что объект может быть любого типа,который является подтипом `Object`.

Пример чтения из списка Wildcard `<?>`:

```
public void printList(List<?> list) {
    for (Object element : list) {
        System.out.println(element);
    }
}
```

1. **Чтение возможно**, так как любой объект является подтипом `Object`.
2. **Запись невозможна**, за исключением добавления null, так как компилятор не знает конкретный тип данных, который будет допустим для вставки.

Пример когда запись не возможна: 

```
List<?> list = new ArrayList<String>();
list.add("test")
```

Сделаем вывод - `<?>` позволяет нам работать с дженериками или коллекциями не уточняя конкретного типа.
Однако это ограничивает возможность модификации содержимого коллекции.

## **Можно ли объявить так `class Animal<?>{}`?**

Нет. Так объявлять нельзя потому что `<?>` можно использовать только в параметризированных типах но не для их объявления.

Для параметризации класса необходимо использовать явные типы, такие как `T, E, K, V`.
`<?>` используется в методах или полях когда тип неизвестен.

## **Принцип PECS**

Принцип **PECS** помогает правильно работать с дженериками в Java.

Аббревиатура расшифровывается **Procedure Extends Consumer Super**
Этот принцип объясняет когда следует использовать `<? extends T>` и  `<? super T>`

 `<? extends T>` используется когда параметризированный тип является поставщиком данных,тоесть только тогда когда мы **читаем данные**.

Пример:

```
public void processAnimals(List<? extends Animal> animals) {
    for (Animal animal : animals) {
        // Можно безопасно работать с объектами типа Animal или его подтипов
        animal.makeSound();
    }
}
```

`<? super T>` используется когда наш параметризированный тип является потребителем данных,тоесть мы передаем данные.

Пример: 

```
public void addAnimal(List<? super Animal> animals) {
    animals.add(new Dog());
    animals.add(new Cat());
}
```

## **WILDCARD**

Wildcard - это специальный символ `?` , который используется в случаях когда нам нужно обозначить неизвестный тип.
Он позволяет параметризировать тип когда конкретный тип не имеет значения.

**Виды Wildcard**:
- Неограниченный `<?>`
- Ограниченный `<? extentds T>`
- Ограниченный с супертипом `<? super T>`


## **Почему последняя строчка не скомпилируется?**

```
List<ArrayList> arrayLists = new ArrayList<ArrayList>();

ArrayList<List> arrayList = new ArrayList<ArrayList>(); // Не скомпилируется
```

Вторая строчка `ArrayList<List> arrayList = new ArrayList<ArrayList>();` не скомпилируется потому что возникает несовместимость типов.

В ней мы пытаемся присвоить объект типа `ArrayList<ArrayList>()` в переменную с типом `ArrayList<List>`,  это не корректно для компилятора.

**Хотя `ArrayList` является подтипом `List`, их использование в обобщённых типах (generics) не является ковариантным, то есть `ArrayList<ArrayList>` не является подтипом `ArrayList<List>`.**

# **Коллекции**

## **Что такое коллекция?**

В Java **коллекция** - это обхект,представляющий собой набор элементов, хранящихся в определенном порядке и по определенным правилам.

**Простыми словами, коллекция — это "коробка", в которую можно положить несколько элементов, таких как числа, строки или объекты, и потом легко их доставать, добавлять, удалять или искать.**

Пример: 

```
List<String> shoppingList = new ArrayList<>();
shoppingList.add("Хлеб");
shoppingList.add("Молоко");
```

## **Какие есть типы коллекций?**

В Java существует **5 основных** типов коллекций. Каждый тип коллекции предназначен для различных сценариев работы с данными.

### 1. **List (Список)**

| Описание               | Упорядоченный набор элементов, где каждый элемент имеет свой номер (индекс). Элементы могут повторяться.                                                                 |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `ArrayList, LinkedList, Vector`                                                                                                                                            |
| **Характеристики**     | **- Доступ по индексу.**<br>**- Поддерживает дубликаты.**<br>**- Можно вставлять и удалять элементы в любом месте списка.**                                                |
Пример:
```
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Создаем список строк
        List<String> shoppingList = new ArrayList<>();
        
        // Добавляем элементы
        shoppingList.add("Хлеб");
        shoppingList.add("Молоко");
        shoppingList.add("Яйца");
        
        // Получаем элемент по индексу
        System.out.println(shoppingList.get(1)); // Выведет "Молоко"
    }
}
```
### 2. **Set (Множество)**

| Описание               | Коллекция, которая хранит только уникальные элементы (без повторений).                                                                                                     |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `HashSet, LinkedHashSet, TreeSet`                                                                                                                                          |
| **Характеристики**     | **- Не допускает повторяющихся элементов.**<br>**- Элементы не имеют индексов.**<br>**- Подходит для хранения уникальных значений, таких как ID или имена.**                |
Пример: 
```
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // Создаем множество
        Set<String> uniqueItems = new HashSet<>();
        
        // Добавляем элементы
        uniqueItems.add("Книга 1");
        uniqueItems.add("Книга 2");
        uniqueItems.add("Книга 1"); // Повтор, не будет добавлен
        
        // Вывод множества
        System.out.println(uniqueItems); // Выведет [Книга 1, Книга 2]
    }
}
```
### 3. **Queue (Очередь)**

| Описание               | Коллекция, которая работает по принципу "первым пришел — первым ушел" (FIFO — First In, First Out).                                                                         |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `LinkedList, PriorityQueue`                                                                                                                                                 |
| **Характеристики**     | **- Элементы добавляются в конец и извлекаются из начала.**<br>**- Используется в задачах, где важно соблюдать порядок обработки, как, например, в очередях на сервере.**   |
Пример:
```
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        // Создаем очередь
        Queue<String> queue = new LinkedList<>();
        
        // Добавляем элементы в очередь
        queue.add("Покупатель 1");
        queue.add("Покупатель 2");
        queue.add("Покупатель 3");
        
        // Извлекаем элемент из начала очереди
        System.out.println(queue.poll()); // Выведет "Покупатель 1"
    }
}
```
### 4. **Deque (Двусторонняя очередь)**

| Описание               | Коллекция, которая позволяет добавлять и удалять элементы с обеих сторон (как в начале, так и в конце).                                                                     |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `ArrayDeque, LinkedList`                                                                                                                                                    |
| **Характеристики**     | **- Двусторонний доступ к элементам (можно добавлять и удалять элементы с обоих концов).**<br>**- Подходит для задач, где важно иметь доступ к элементам с обеих сторон.**  |
Пример: 
```
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void main(String[] args) {
        // Создаем двустороннюю очередь
        Deque<String> deque = new ArrayDeque<>();
        
        // Добавляем элементы с обоих концов
        deque.addFirst("Первый");
        deque.addLast("Последний");
        
        // Извлекаем элементы
        System.out.println(deque.removeFirst()); // Выведет "Первый"
        System.out.println(deque.removeLast());  // Выведет "Последний"
    }
}
```
### 5. **Map (Отображение)**

| Описание               | Коллекция, которая хранит пары "ключ-значение". Каждый ключ уникален, а значение может быть связано с этим ключом.                                                          |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Примеры реализаций** | `HashMap, TreeMap, LinkedHashMap`                                                                                                                                           |
| **Характеристики**     | **- Хранит пары "ключ-значение".**<br>**- Ключи уникальны, но значения могут повторяться.**<br>**- Подходит для хранения данных, которые легко искать по ключу, как телефонная книга.** |
Пример:
```
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Создаем отображение (словарь)
        Map<String, String> phoneBook = new HashMap<>();
        
        // Добавляем записи в словарь
        phoneBook.put("Алиса", "123-4567");
        phoneBook.put("Боб", "987-6543");
        
        // Получаем значение по ключу
        System.out.println(phoneBook.get("Алиса")); // Выведет "123-4567"
    }
}
```
